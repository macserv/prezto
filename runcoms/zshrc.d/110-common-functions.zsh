##
##  ZSHRC EXTENSION:
##  Functions: Common
##


################################################################################
##  SHARED / HELPERS

####
##  "Comment" a line of text in a way that is visible in a list of commands.
##  This function does nothing, and does not make use of the arguments passed to
##  it.  The arguments are ignored, and can be used to make a general comment.
##
##  This differs from '#' in that comments following '//' will appear in the
##  listing of a function's script as reported by commands like 'which'.
##
##  Caveat: The comment words are arguments to the function named '//'.  Unlike
##      a normal comment created by using the '#' character, the "commenting"
##      effect of '//' ends at a control structure (e.g., ';', '&&', parentheses
##      or braces, etc.).
##
##  EXAMPLE 1
##  ---------
##  % function comment_hash () { # comment, yo! }
##  function>
##  # The octalthorpe character prevented the closing brace from being
##  # interpreted, so zle is now expecting more lines.
##
##  EXAMPLE 2
##  ---------
##  % function comment_hash () {
##  function>     # comment, yo!
##  function> }
##  % which comment_hash
##  comment_hash () {
##
##  }
##  # Normal '#' comments are not stored when a function is created, so they
##  # can't be seen in the output of 'which'.
##
##  EXAMPLE 3
##  ---------
##  % function comment_slash () { // comment, yo! }
##  % which comment_slash
##  comment_slash () {
##      // comment, yo!
##  }
##  # The slashed command is included in 'which` output.
##
function // ()  # [comment_word ...]
{
    # Function intentionally empty.
}


####
##  Echo to StdErr instead of StdOut.
##  Arguments will be passed through to 'echo' command.
##
function echo_err ()  # [echo-arg ...] words ...
{
    echo $@ 1>&2
}


####
##  Echo to StdErr when $ENABLE_ECHO_DEBUG is greater than zero.
##  Arguments will be passed through to 'echo' command.
##
function echo_err_debug ()  # [-n] words ...
{
    (( ENABLE_ECHO_DEBUG )) || return 0
    echo_err $@
}


####
##  Echo a log message with consistent formatting, including tracing info and
##  a message prefix based on the severity of the message.
##
##  OUTPUT FILE DESCRIPTOR
##  ----------------------
##  Messages generated by 'echo_log' are sent to 'stderr' so that they do not
##  interfere with the functionality of functions which print text to 'stdout'
##  which is intended for consumption by a calling function.
##
##  ARGUMENTS
##  ---------
##  --help : Print command usage and exit.
##
##  --level : Optional.  Indicates the severity of the message to be logged.
##      Can be any of the following:
##
##      | Type     | Sample              |
##      | -------- | ------------------- |
##      | ERROR    | "[ERROR] message"   |
##      | WARNING  | "[WARNING] message" |
##      | INFO     | "[INFO] message"    |
##      | DEBUG    | "[DEBUG] message"   |
##      | <custom> | "[custom] message"  |
##      | (none)   | "message"           |
##
##  --indent : Optional.  The number of indentation levels which should
##      precede the message.  Default: 0.
##
##  --fill : Optional.  The string which will be repeated to fill the
##      indented space.  Default: spaces will be used as fill.
##
##  --spacer : Optional.  A string which will replace the filler immediately
##      before the message.  Default: none.
##
##  --transparent : Make the caller transparent; that is, ignore the calling
##      function, and report its parent instead.  This is useful when you want
##      to "transparently" wrap `echo_log` in another logging function without
##      it being displayed as the caller.
##
##  [message]  The message to be logged.  To read this from stdin, use '--'.
##      This function will interpret its last positional argument as the
##      message; bear this in mind if you include arguments for the 'echo'
##      command (see the next section).
##
##  ADDITIONAL ARGUMENTS PASSED THROUGH TO 'echo'
##  ---------------------------------------------
##  Any additional options provided to this function will be passed along to
##  the 'echo' command (via the 'echo_err' function).  Bear in mind that this
##  function will interpret its last positional argument as the message, so,
##  to provide arguments for 'echo' with no message, add an empty
##  string argument.
##
##  STATUS PASS-THROUGH
##  ---------------------
##  The 'echo_log' command will return the same status as the command which was
##  executed immediately beforehand.  This eliminates the need to capture the
##  prior command's status to return it after logging.
##
##  ENVIRONMENT VARIABLES
##  ---------------------
##  ${ECHO_LOG_INDENT_SPACES}: If this parameter is set to an non-negative
##      integer value, it will be used to determine the number of spaces
##      leading the message for each level of indentation.
##      Default: 4.
##
##  LOG MESSAGE TRACE PREFIX
##  ------------------------
##  Each log message is prefixed with the following three details, useful for
##  tracing script execution:
##      * The base name of the script being executed.
##            * If `echo_log` is invoked on the command line, this will be the
##              name of the shell (e.g. 'zsh').
##            * If `echo_log` is invoked from within a function created on the
##              command line, this will be empty.
##      * The line number of the `echo_log` statement within the script.
##            * If `echo_log` is invoked on the command line, this represents
##              the history event of the command.
##      * The function within which `echo_log` was called.  If function calls
##        are nested, this is the function nearest the top of the stack.
##            * If `echo_log` is invoked within an anonymous function, this will
##              report as `(anon)` (as of zsh 5.8.1).
##
##  EXAMPLE
##  -------
##  function test_logs ()
##  {
##      echo_log
##      echo_log --level 'INFO' ''
##      echo_log --level 'INFO' 'Info message.'
##      echo_log --level 'WARNING' 'Warning message.'
##      echo_log --level 'ERROR' 'Error message!'
##      echo_log --level 'DEBUG' 'Debug message, unindented.'
##      echo_log -n --level 'DEBUG' --indent 1 'Debug message, indented once, supressing newline...'
##      echo_err 'until now!'
##      echo_log --level 'DEBUG' --indent 2 --fill '-' --spacer ' ' 'Debug, indented 2 times, with dash fill and final space.'
##      echo_log --level 'DEBUG' --indent 2 --fill ' ' --spacer '-> ' 'Debug, indented 2 times, with space fill and final arrow.'
##      echo_log --level 'DEBUG' --indent 3 --fill '. ' 'Debug, indented 3 times, with alternating dots and spaces.'
##      echo_log --level 'DEBUG' --indent 4 --fill '... ' 'Debug, indented 4 times, with dots in groups of three.'
##      function { echo_log --level 'HACK' 'Anonymous invocation with custom 'HACK' log type.' }
##      echo "Message from stdin with custom 'PASS' type." | echo_log --level 'PASS' --
##      echo_err
##  }
##
##  EXAMPLE OUTPUT (after copying the above function to the pasteboard)
##  -------------------------------------------------------------------
##  % pbpaste >! $TMPDIR/logtest.zsh
##  % source $TMPDIR/logtest.zsh
##  % test_logs
##  [logtest.zsh:3(test_logs)]
##  [logtest.zsh:4(test_logs)] [INFO]
##  [logtest.zsh:5(test_logs)] [INFO] Info message.
##  [logtest.zsh:6(test_logs)] [WARNING] Warning message.
##  [logtest.zsh:7(test_logs)] [ERROR] Error message!
##  [logtest.zsh:8(test_logs)] [DEBUG] Debug message, unindented.
##  [logtest.zsh:9(test_logs)] [DEBUG]     Debug message, indented once, supressing newline... until now!
##  [logtest.zsh:11(test_logs)] [DEBUG] ------- Debug, indented 2 times, with dash fill and final space.
##  [logtest.zsh:12(test_logs)] [DEBUG]      -> Debug, indented 2 times, with space fill and final arrow.
##  [logtest.zsh:13(test_logs)] [DEBUG] . . . . . . Debug, indented 3 times, with alternating dots and spaces.
##  [logtest.zsh:14(test_logs)] [DEBUG] ... ... ... ... Debug, indented 4 times, with dots in groups of three.
##  [logtest.zsh:15((anon))] [HACK] Anonymous invocation with custom HACK log type.
##  [logtest.zsh:16(test_logs)] [PASS] Message from stdin with custom 'PASS' type
##  % echo_log --level 'OK' "Direct invocation on command line with custom 'OK' type."
##  [-zsh:4] [OK] Direct invocation on command line with custom 'OK' type.
##
function echo_log ()
{
    ## Capture status of previous command.
    typeset -i passthrough_status=$?

    ## Create usage output.
    typeset -a usage=(
        "$0 [--help | -h | -?]"
        "$0 [--level <FAIL | ERROR | WARNING | INFO | DEBUG | (custom)>]"
        '    [--indent <levels>] [--fill <chars>] [--spacer <chars>]'
        '    [--transparent] [message]'
    )

    ## Define options array with defaults.
    typeset -A options=( '--transparent' 0 )

    ## Configure parser and process function arguments.
    typeset -a parse_config=(
    #   '-a' 'options' # Specifies a default array to contain recognized options.
        '-A' 'options' # Same as -a, but using an associative array. Test: (( ${+options[--foo]} ))
        '-D'           # Remove found options from the positional parameters array ($@).
        '-E'           # Don't stop at the first string that isn't described by the specs.
    #   '-F'           # Stop and exit if a param is found which is not in the specs.
    #   '-K'           # Don't replace existing arrays (allows default values).
        '-M'           # Allows the 'name' in '=name' to reference another spec.
        '--'           # Indicates that options end here and spec starts.
        '-help' 'h=-help' '?=-help'
        '-level:'
        '-indent:'
        '-fill:'
        '-spacer:'
        '-transparent'
    )

    ## Load parser and process function arguments.
    zmodload zsh/zutil && zparseopts ${parse_config[@]} || { echo_err 'Failed to load or configure zparseopts command.' ; return $? ; }

    ## Display usage if help flag is set.
    (( ${+options[--help]} )) && { print -l "${usage}" && return 0 ; }

    typeset message="${@[-1]}"
    [[ "${message}" == '--' ]] && read -r message

    typeset level="${options[--level]}"
    typeset prefix
    case "${level}" in
        FAIL)    prefix="[FAIL]"               ;;
        ERROR)   prefix="[ERROR]"              ;;
        WARNING) prefix="[WARNING]"            ;;
        INFO)    prefix="[INFO]"               ;;
        DEBUG)   prefix="[DEBUG]"              ;;
        *)       prefix="${level:+[${level}]}" ;;
    esac

    typeset -i indent_level=$(( ${options[--indent]} ))
    (( indent_level )) &&
    {
        typeset -i indent_spaces=${ECHO_LOG_INDENT_SPACES:-4}
        (( indent_spaces < 0 )) && indent_spaces=0

        typeset -i message_length=$(( ${#message} + (${indent_level} * ${indent_spaces}) ))
        typeset filler="${options[--fill]}"
        typeset spacer="${options[--spacer]}"

        [[ -n "$spacer" ]] &&
            { message=${(pl:$message_length::$filler::$spacer:)message} ; } ||
            { message=${(pl:$message_length::$filler:)message} ; }
    }

    typeset -i file_trace_index=1
    typeset -i func_stack_index=2

    # Workaround for issue which causes an entry to be added to the top of the
    # file trace when an anonymous function calls 'echo_log' from a function
    # within a file which has been 'source'd, not executed directly.
    [[ "${funcfiletrace[$file_trace_index]}" == ':'* ]] && { file_trace_index+=1 }

    # If the '--transparent' flag is set, look one index higher in the stack
    # and file trace arrays to functionally ignore the caller.
    (( ${+options[--transparent]} )) &&
    {
        file_trace_index+=1
        func_stack_index+=1
    }

    typeset file=${funcfiletrace[$file_trace_index]##*/}
    typeset func=${funcstack[$func_stack_index]}
    typeset output="[${file:+"$file"}${func:+"($func)"}]${prefix:+ ${prefix}}${message:+ ${message}}"

    # Call `echo_err`, passing extra arguments through (e.g., '-n').
    echo_err ${@[1,-2]} "${output}"

    return ${passthrough_status}
}


####
##  Echo a debug message, using the 'echo_log' mechanism, which will only be
##  printed if debug echo is enabled (see GLOBAL PARAMETERS).
##
##  The log type will be set to '[DEBUG]', and the '--transparent' flag will be
##  enabled automatically.
##
##  SEE ALSO: `echo_log`
##  --------------------
##  This function is a wrapper around the `echo_log` function.  Please refer to
##  the documentation for 'echo_log' to find additional details about the
##  arguments and environment variables affectring its behavior.
##
##  ARGUMENTS
##  ---------
##  --help : Print command usage and exit.
##
##  --indent : Optional.  The number of indentation levels which should
##      precede the message.  Default: 0.
##
##  --fill : Optional.  The string which will be repeated to fill the
##      indented space.  Default: spaces will be used as fill.
##
##  --spacer : Optional.  A string which will replace the filler immediately
##      before the message.  Default: none.
##
##  [message] : The message to be logged.  To read this from stdin, use '--'.
##      This function will interpret its last positional argument as the
##      message; bear this in mind if you include arguments for the 'echo'
##      command (see the next section).
##
##  ADDITIONAL ARGUMENTS PASSED THROUGH TO 'echo'
##  ---------------------------------------------
##  Any additional options provided to this function will be passed along to
##  the 'echo' command (via the 'echo_err' function).  Bear in mind that this
##  function will interpret its last positional argument as the message, so,
##  to provide arguments for 'echo' with no message, add an empty
##  string argument.
##
##  STATUS PASS-THROUGH
##  ---------------------
##  The 'echo_debug' command will return the same status as the command which
##  was executed immediately beforehand.  This eliminates the need to capture
##  the prior command's status to return it after logging.
##
##  ENVIRONMENT VARIABLES
##  ---------------------
##  ${ENABLE_ECHO_DEBUG}: This parameter must be set to an integer greater
##      than zero for messages to be printed to the console.
##
function echo_debug ()
{
    typeset -i passthrough_status=$?

    (( ENABLE_ECHO_DEBUG )) || return ${passthrough_status}

    typeset message="${1}"
    [[ "${message}" == '--' ]] && read -r message || { } # Avoid passing non-zero status to `echo_log`

    # TODO strip --level argument (if present) to force DEBUG

    echo_log --level 'DEBUG' --transparent $@

    return ${passthrough_status}
}


####
##  Print a consistently-formatted log message useful for tracing a failure,
##  and call `exit` (with customizable status code).
##
##  ARGUMENTS
##  ---------
##
##  --help : Print command usage and exit.
##  [message] : Optional.  The message to be displayed.
##  [status] : Optional.  The status code to be returned by `exit`.  Default: 1
##
##  EXAMPLE
##  -------
##  This one-liner...
##
##      eject_warp_core || fail "Ejector systems off-line ($?)." $?
##
##  ... is equivalent to this...
##
##      eject_warp_core
##      typeset -i eject_status=$?
##      (( eject_status == 0 )) ||
##      {
##          echo_log --level 'FAIL' "Ejector systems offline (${eject_status})."
##          exit ${eject_status}
##      }
##
##  PREVENTING EXIT (Debug)
##  -----------------------
##  In cases where it would be helpful to supress this behavior (e.g., testing
##  and debugging), prevent this behavior, a subshell can be used to allow
##  execution to continue.  For example:
##      % fail 'Bar' || echo 'Baz'
##      [-zsh:1] [FAIL] Bar
##      % ( fail 'Bar' ) || echo 'Baz'
##      [-zsh:2] [FAIL] Bar
##      Baz
##
function fail ()  # [message] [status]
{
    typeset    fail_message="${1:-An error ${2:+(${2}) }occurred.}"
    typeset -i fail_status=${2:-1} || { echo_log --level 'ERROR' "Invalid status code: '${2}'." }

    echo_log --level 'FAIL' "${fail_message}"
    exit ${fail_status}
}


####
##  Get the user name of the account which logs into this system most commonly.
##
function local_user_name ()
{
    echo "${JAMF_GLOBAL_LOGGED_IN_OR_SS_USER:-$( user_most common )}"
}


####
##  Get the user name of the account which is currently logged in to this
##  system's console
##
function console_user_name ()
{
    echo "${JAMF_GLOBAL_LOGGED_IN_OR_SS_USER:-$( user_most recent --online-only )}"
}


####
##  Get the UID for the the specified user name.
##
function user_id_for_name ()  # <user_name>
{
    typeset user_name="${1}"
    [[ -n "${user_name}" ]] || { echo_log --level 'ERROR' "Missing argument for user name." ; return 1 ; }

    /usr/bin/id -u "${user_name}"
}


####
##  Get the local home directory for the system's local user.
##
function local_user_home ()
{
    /usr/bin/dscl -plist '.' -read "/Users/$( local_user_name )" | /usr/bin/plutil -extract 'dsAttrTypeStandard:NFSHomeDirectory.0' 'raw' -o - -
}


####
##  Get the info dictionary plist for a network user.
##
function network_user_info ()  # [standard_id] [ad_domain]
{
    typeset -l standard_id="${1:-$( local_user_name )}"
    typeset -l ad_domain="${2}"
    typeset -a search_domains=( ${DSCL_ACTIVE_DIRECTORY_HOSTS} )

    [[ -n "${ad_domain}" ]] &&
    {
        (( ${DSCL_ACTIVE_DIRECTORY_HOSTS[(Ie)$ad_domain]} )) || { echo_log --level 'ERROR' "Specified AD domain '${ad_domain}' is not one of '${(j:', ':)DSCL_ACTIVE_DIRECTORY_HOSTS}'." ; return 10 ; }

        search_domains=( ${ad_domain} )
    }

    typeset user_info
    for search_domain ( ${search_domains} )
    {
        echo_debug "Fetching info for SID '${standard_id}' in '${search_domain}' domain..."
        user_info=$( /usr/bin/dscl -plist -q "${DSCL_ACTIVE_DIRECTORY_ROOT}/${search_domain}" -read "/Users/${standard_id}" 2>/dev/null ) && break
    }

    [[ -n "${user_info}" ]] || { echo_debug "Unable to find user info for SID '${standard_id} in '${(j:', ':)search_domains}'."; return 20 ; }

    echo -E "${user_info}"
}


####
##  Get the local home directory for the system's local user.
##
function network_user_home ()  # [standard_id] [ad_domain]
{
    typeset user_info && user_info=$( network_user_info $@ ) || return $?

    echo -E "${user_info}" | /usr/bin/plutil -extract 'dsAttrTypeStandard:SMBHome.0' 'raw' -o - -
}


####
##  Get the group membership for the specified user.
##
function network_user_groups ()  # [--csv] [standard_id] [ad_domain]
{
    typeset -i use_csv_output=0
    [[ "${1}" == "--csv" ]] && { use_csv_output=1 && shift ; }

    typeset user_info && user_info=$( network_user_info $@ ) || return $?
    typeset groups_attr='dsAttrTypeNative:memberOf'
    typeset -i group_count && group_count=$( echo -E "${user_info}" | /usr/bin/plutil -extract "${groups_attr}" 'raw' -o - - )
    typeset -a group_dnames=()

    for group_index ( {0..$(( group_count - 1 ))} )
    {
        group_dnames+=$( echo -E "${user_info}" | /usr/bin/plutil -extract "${groups_attr}.${group_index}" 'raw' -o - - )
    }

    typeset cn_segment
    typeset -a group_segments
    typeset -a ou_segments
    typeset -a dc_segments
    typeset segment_value
    typeset -a output_lines=()
    typeset -a output_pipe_cmd=( '/usr/bin/column' '-t' '-s' ',' )

    for group_dn ( ${(i)group_dnames} )
    {
        group_segments=( ${(@s:=:)${(s:,:)group_dn}} )
        ou_segments=()
        dc_segments=()

        for segment_index ( $(seq 1 2 $(( ${#group_segments} - 1 ))) )
        {
            segment_value="${group_segments[$(( segment_index + 1 ))]}"

            case ${group_segments[segment_index]}
            {
                'CN') cn_segment="${segment_value}" ;;
                'OU') ou_segments+="${segment_value}" ;;
                'DC') dc_segments+="${segment_value}" ;;
                *)    echo_log --level 'ERROR' 'Unexpected label found in DN: '${group_dn}'.' return 10 ;;
            }
        }

        output_lines+="${cn_segment},${(Oaj:/:)ou_segments},${(Oaj:.:)dc_segments}"
    }

    (( use_csv_output )) &&
    {
        output_pipe_cmd=( 'cat' )
        echo 'Name (CN),Path (OU),Domain (DC)'
    }

    echo ${(j:\n:)output_lines} | $output_pipe_cmd[@]
}


####
##  Run a command as user with the given UID.
##
function run_as_user_id ()  # <user_id> [command word ...]
{
    typeset -i user_id="${1}" ; shift ;
    launchctl asuser "${user_id}" sudo --user "#${user_id}" $@
}


####
##  Run a command as user with the given user name.
##
function run_as_user_named ()  # <user_name> [command word ...]
{
    typeset user_name="${1}" ; shift ;
    run_as_user_id $( user_id_for_name "${user_name}" ) $@
}


####
##  Run a command as the account which logs in most frequently.
##
function run_as_local_user ()  # [command word ...]
{
    typeset local_user && local_user=$( local_user_name ) || return 1
    [[ -n "${local_user}" ]] || { echo_log --level 'ERROR' 'No local user could be identified.' ; return 1 ; }
    run_as_user_named "${local_user}" $@
}


####
##  Run a command as the logged-in user.
##
function run_as_console_user ()  # [command word ...]
{
    typeset console_user && console_user=$( console_user_name ) || return 1
    [[ -n "${console_user}" ]] || { echo_log --level 'ERROR' 'No user is currently at the console.' ; return 1 ; }
    run_as_user_named "${console_user}" $@
}


####
##  Extract the value of the given keypath from a JSON object string.
##
##  NOTE: This uses the `plutil` command, whose JSON-handling capability is
##  undocumented, and may disappear without notice.
##
function value_for_keypath_in_json ()  # <keypath> <json_string>
{
    typeset keypath="${1}"
    typeset json_string="${2}"

    [[ -z "${keypath}" || -z "${json_string}" ]] &&
    {
        echo_log --level 'ERROR' "Missing input for either the key to be extracted or the JSON object."
        return 1
    }

    echo "${json_string}" | /usr/bin/plutil -extract "${keypath}" 'raw' -o - -
}


####
##  Present a GUI alert with a single button to let the user know that
##  an error has occurred.
##
##  OUTPUT
##  ------
##  The button which was clicked, e.g.: "buttonReturned:OK"
##
##  ARGUMENTS
##  ---------
##  $1: [message]  Optional.  The "message" to be shown in the alert.
##  $2: [title]  Optional.  The alert title.  Default: "An error occurred".
##  $3: [button_label]  Optional.  The button label.  Default: "OK".
##
##  EXAMPLES
##  --------
##  alert_dialog 'Nothing too serious'
##  alert_dialog 'You do not have the correct permissions to do this.' \
##               'Could not create user'
##  alert_dialog 'KLINGONS OFF THE STARBOARD BOW, CAPTAIN' \
##               'RED ALERT' \
##               'BATTLE STATIONS'
##
function display_alert_dialog ()
{
    typeset message="${1}"
    typeset title="${2:-An error occurred.}"
    typeset button_label="${3:-OK}"

    echo_debug "Displaying alert dialog to user:"
    echo_debug --indent 1 "┌────────────────────────────────────────────────────────────────────────────────"
    echo_debug --indent 1 "│ ${title}"
    echo_debug --indent 1 "├────────────────────────────────────────────────────────────────────────────────"
    echo_debug --indent 1 "│ ${message}"
    echo_debug --indent 1 "│"
    echo_debug --indent 1 "│ [${button_label}]"
    echo_debug --indent 1 "└────────────────────────────────────────────────────────────────────────────────"

    /usr/bin/osascript 2>/dev/null <<EOAPPLESCRIPT

        display alert "$title" as critical message "$message" buttons { "$button_label" } default button "$button_label"

EOAPPLESCRIPT
}


####
##  Present a notification in the notification center.
##
##  ARGUMENTS
##  ---------
##  $1: <message>  The "message" to be shown in the notification.
##  $2: [title]  Optional.  The notification's title.  Default: "Notification"
##  $3: [subtitle]  Optional.  The notification's subtitle.
##
function display_notification ()  # <message> <title> <button_label>
{
    [[ -n "${1}" ]] || { echo_log --level 'ERROR' "A message must be provided for the notification." ; return 1 ; }

    echo_debug "Displaying notification to user with message '${message}', title '${2}', subtitle '${3}'."

    run_as_console_user /usr/bin/osascript 2>/dev/null <<EOAPPLESCRIPT

                display notification "${1}" with title "${2:-Notification}" subtitle "${3}"

EOAPPLESCRIPT
}


####
##  Present a GUI selection user interface to allow the user to choose from a
##  list of available options.
##
##  OUTPUT
##  ------
##  The item which was selected.
##
##  ARGUMENTS
##  ---------
##  $1: [title]  The list title.
##  $2: [message]  The message prompting to select an item.
##  $3-$n: [item ...]  The items which will appear in the list.
##
##  RETURN STATUS
##  -------------
##  0: An item was chosen normally.
##  10: The "Cancel" button was clicked.
##
function select_from_list_dialog ()  # [title] [message] [item ...]
{
    typeset    title="$1"
    typeset    message="$2"
    typeset -a items=( ${@:3} )
    typeset    quoted_items=${(j[, ])${(qqq)items[@]}}

    echo_debug "Displaying alert dialog to user: '${title}' / '${message}' / [ ${quoted_items} ]"

    typeset selected_item ; selected_item=$( /usr/bin/osascript 2>/dev/null <<EOAPPLESCRIPT

        set listOptions to { $quoted_items }
        choose from list listOptions \
            with title "$title" \
            with prompt "$message" \
            OK button name "OK" \
            cancel button name "Cancel"

EOAPPLESCRIPT
    )

    [[ "${selected_item}" == "false" ]] && return 10

    echo "${selected_item}"
}


####
##  Silently determine if a user is a member of a given group.
##
##  ARGUMENTS
##  ---------
##  $1: <user_name>  The name of the user to be verified.
##  $2: <group_name>  The group which is to be checked for membership.
##
##  Return Codes:
##        0: The user is a member of the given group.
##      121: Argument for user name is missing or empty.
##      122: Argument for group name is missing or empty.
##        n: The user is not a member of the given group, or the membership
##           check failed, `dseditgroup` code returned.
##
function check_user_for_group_membership ()  # <user_name> <group_name>
{
    typeset user_name="${1}"  ; [[ -n "${user_name}"  ]] || return 121
    typeset group_name="${2}" ; [[ -n "${group_name}" ]] || return 122

    echo_debug "Checking whether '${user_name}' is a member of '${group_name}'..."
    /usr/sbin/dseditgroup -o checkmember -m "${user_name}" "${group_name}" >/dev/null
}


####
##  Silently attempt to add a user to the specified group.
##
##  ARGUMENTS
##  ---------
##  $1: <user_name>  The name of the user to be added to the group.
##  $2: <group_name>  The group to which the user should be added.
##
##  Return Codes:
##        0: The user was added successfully.
##      121: Argument for user name is missing or empty.
##      122: Argument for group name is missing or empty.
##        n: The operation to add the user failed; returns `dseditgroup` status.
##
function add_user_to_group ()  # <user_name> <group_name>
{
    typeset user_name="${1}"  ; [[ -n "${user_name}"  ]] || return 121
    typeset group_name="${2}" ; [[ -n "${group_name}" ]] || return 122

    check_user_for_group_membership "${user_name}" "${group_name}" && return 0

    echo_debug "Adding '${user_name}' to group '${group_name}'..."
    /usr/sbin/dseditgroup -o edit -a "${user_name}" -t user "${group_name}" >/dev/null
}


####
##  Print the available disk space for a given mount point or device path.
##  By default, the returned value is expressed in megabytes.
##
##  ARGUMENTS
##  ---------
##  --bytes:  Optional.  Express the returned available space in bytes instead
##      of megabytes.
##
##  $1: <volume_path>  The mount point or device path.  If no argument is
##      provided, the root path '/' will be used.
##
function free_in_volume ()  # [--bytes] <volume_path>
{
    typeset -i use_bytes=0
    [[ "${1}" == "--bytes" ]] && { use_bytes=1 ; shift ; }

    typeset volume_path="${1}"
    [[ -z "${volume_path}" ]] && { volume_path='/' } ||  # Use default if unset.  Otherwise...
    {
        [[ -d "${volume_path}" ]] ||  # Verify provided path is a directory.
        {
             echo_debug "Specified volume path '${volume_path}' is not a directory."
             return 1
        }
    }

    typeset volume_info && volume_info="$( /usr/sbin/diskutil info -plist "${volume_path}" )" ||
    {
        echo_debug "Unable to get disk info for '${volume_path}'."
        return $?
    }

    typeset free_bytes && free_bytes="$( echo "${volume_info}" | /usr/bin/plutil -extract 'APFSContainerFree' 'raw' -o - - )" ||
    {
        echo_debug "Unable to parse free disk space for '${volume_path}'."
        return $?
    }

    (( use_bytes )) &&
    {
        echo "${free_bytes}"
        return 0
    }

    # Limit MB format output to three decimal places.
    typeset -F 3 free_mbytes && free_mbytes=$(( free_bytes / (1024.0 ** 2) ))

    echo "${free_mbytes}"
}


####
##  Remove a file or directory, with a test for existence and debug log message.
##
##  ARGUMENTS
##  ---------
##  $1: <path_to_remove>  The path to the file or directory to be removed.
##
function remove_existing ()  # <path_to_remove>
{
    [[ -f "${1}" ]] && { echo_debug "Removing file '${1}'..."      ; /bin/rm  -f "${1}" ; return $? ; }
    [[ -d "${1}" ]] && { echo_debug "Removing directory '${1}'..." ; /bin/rm -rf "${1}" ; return $? ; }

    echo_debug "No file or directory exists at '${1}'... skipped."
    return 0
}


####
##  Scans for bundles within a folder, and prints the path to each bundle whose
##  `CFBundleIdentifier` property matches the given bundle ID.
##
##  With only one argument, this function will search for `.app` bundles in
##  the `/Applications` folder which match the specified identifier.
##
##  ARGUMENTS
##  ---------
##  $1: <search_id>  The bundle identifier which this function should match.
##  $2: <folder>  Optional.  The path to the folder which contains the items
##      to be scanned.  Default: `/Applications`
##  $3: <extension>  Optional.  The extension required for a bundle to be
##      scanned.  Default: `app`
##
function find_bundle_with_id ()  # <search_id> [folder] [extension]
{
    typeset search_id="${1}"               && [[ -n "${search_id}" ]] || return 10
    typeset folder="${2:-'/Applications'}" && [[ -d "${folder}" ]]    || return 20
    typeset extension="${3:-'app'}"
    typeset bundle_id

    for bundle ( ${folder}/*.${extension} )
    {
        bundle_id=$( /usr/bin/plutil -extract 'CFBundleIdentifier' 'raw' "${bundle}/Contents/Info.plist" ) || continue
        [[ "${bundle_id}" == "${search_id}" ]] || continue
        echo "${bundle}"
    }
}


####
##  Print either the most recently logged-in user, or the user who logs in most
##  commonly, with options to filter out undesired users.
##
##  ARGUMENTS
##  ---------
##  <recent | common>  Operating Mode
##      'recent' : Print the name of the most recently logged-in user, filtered
##          by the options below.
##      'commmon' : Print the name of the user who logs in most commonly,
##          filtered by the options below.
##
##  FILTERING OPTIONS (Optional):
##      [-o | --online-only]  Consider only users who are currently logged in.
##      [-n | --include-non-sid]  Include users whose names do not appear to be
##          a standard identifier (a letter followed by six digits).
##      [-t | --include-tty]  Include logins that are not bound to a console
##          session; i.e., non-GUI logins such as terminal or SSH sessions.
##      [-p <pattern> | --pattern <pattern>]  Filter out any usernames which do
##          not match the given ``pattern``.
##
function user_most ()  # (recent | common) [-o | --online_only] [-n | --include-non-sid] [-t | --include-tty] [-p <pattern> | --pattern <pattern>]
{
    # Parse the options given to the function.
    zmodload zsh/zutil || return 10
    zparseopts -D -E -F -- \
        {h,-help}=arg_help \
        {o,-online-only}=arg_online_only \
        {n,-include-non-sid}=arg_include_non_sid \
        {t,-include-tty}=arg_include_tty \
        {p,-pattern}:=arg_pattern \
    || return 1

    # Configure the list of valid operating modes for this function.
    typeset -A modes=(
        mode_recent 'recent'
        mode_common 'common'
    )

    # Read the selected operating mode.  If the mode is not set or is not valid,
    # set the 'help' flag so that the usage text will be displayed.
    typeset mode="${1}"
    (( ${${(@v)modes}[(Ie)$mode]} )) || { arg_help=( '--help' ) }

    # If the 'help' flag is set, display this function's usage text.
    if (( $#arg_help )); then
        print -rC1 -- \
            "$0 [-h | --help]" \
            "$0 (${(j' | ')modes}) [-n | --include-non-sid] [-t | --include-tty] [-o | --online-only]"
        return 0
    fi

    # Configure 'awk' filter patterns to be ANDed together later.
    typeset -A filters=(
        is_not_blank    '(! /^$/)'
        is_not_status   '(! /wtmp begins/)'
        is_sid          '($1 ~ /^[[:alpha:]][[:digit:]]{6}$/)'
        is_console      '($2 == "console")'
        is_online       '/still logged in/'
        matches_pattern "(\$1 ~ /${arg_pattern[2]}/)"
    )

    # Configure 'awk' actions which will be combined later.
    typeset -A actions=(
        print_first_field  'print $1'
        print_second_field 'print $2'
        stop_reading       'exit 0'
    )

    # Create arrays to hold the patterns and actions for this function run.
    # Populate with filters and required regardless of mode.
    typeset -a awk_filters=( "${filters[is_not_blank]}" "${filters[is_not_status]}" )
    typeset -a awk_actions=( "${actions[print_first_field]}" )

    # If we're in 'recent' mode, we'll stop reading after the filtering action.
    [[ "${mode}" == "${modes[mode_recent]}" ]] && { awk_actions+=( "${actions[stop_reading]}" ) }

    # Add filters based on flags passed to command.
    (( $#arg_include_non_sid )) || { awk_filters+=( "${filters[is_sid]}" ) }
    (( $#arg_include_tty ))     || { awk_filters+=( "${filters[is_console]}" ) }
    (( $#arg_online_only ))     && { awk_filters+=( "${filters[is_online]}" ) }
    (( $#arg_pattern ))         && { awk_filters+=( "${filters[matches_pattern]}" ) }

    # Construct the 'awk' script, using the (j) zsh parameter expansion flag to
    # join the patterns and actions determined above.
    awk_script="${(j' && ')awk_filters} { ${(j'; ')awk_actions} }"

    # Run the 'awk' command, using the constructed script.
    awk_output=$( /usr/bin/last | awk "${awk_script}" )

    # If we're in 'recent' mode, we're done here... echo the output and exit.
    [[ "${mode}" == "${modes[mode_recent]}" ]] &&
    {
        echo "${awk_output}"
        return 0
    }

    # Otherwise, since we're in 'common' mode, pipe the output through a few
    # commands to determine the most frequent user.
    echo "${awk_output}" \
        | sort \
        | uniq -c \
        | sort -rn \
        | awk "{ ${actions[print_second_field]}; ${actions[stop_reading]} }"
}


####
##  Print a "unique" path for a given file path; useful when you wish to avoid
##  overwriting an existing file.
##
##  ARGUMENTS
##  ---------
##  $1: <path>  Path to test for uniqueness
##
##  BEHAVIOR
##  --------
##  Determines whether or not a file or directory exists at the given path.
##      * If no file/folder exists, function outputs the path unmodified.
##      * If file/folder exists, function attempts to generate a unique path by
##        appending the smallest-possible integer to the end which would result
##        in a unique file path.
##
function unique_path ()  # <path>
{
    typeset working_path="${1:a}" ; [[ -n "${working_path}" ]] || { echo_log --level 'ERROR' 'Missing input path argument.' ; return 10 ; }
    typeset base_and_stem="${working_path:r}"
    typeset extension_with_dot="${${working_path:e}:+.${working_path:e}}"
    typeset -i index=0

    # Handle case of dotfile with no extension.  The fact that :r/:e don't
    # handle this properly should probably be considered to be a ZSH bug.
    # TODO: Report it: https://zsh.sourceforge.io/FAQ/zshfaq06.html
    [[ "${working_path:t}" == ".${working_path:e}" ]] &&
    {
        base_and_stem="${working_path}"
        unset extension_with_dot
    }

    while [[ -e $working_path ]] { working_path="${base_and_stem}-$((++index))${extension_with_dot}" ; }

    echo "${working_path}"
}


####
##  Replace the contents of target_file with those of source_file, preserving
##  the metadata and modification date of the target_file.
##
function mv_replace ()  # <source_file> <target_file>
{
    typeset source_file=${~"${1}"} ; [[ -n "${source_file}" && -f "${source_file}" ]] || { echo_log --level 'INFO' 'Argument for source file is missing or empty, or file does not exist.' ; return 10 ; }
    typeset target_file=${~"${2}"} ; [[ -n "${target_file}" && -f "${target_file}" ]] || { echo_log --level 'INFO' 'Argument for target file is missing or empty, or file does not exist.' ; return 11 ; }

    typeset target_date_modified && target_date_modified="$(stat -f "%Sm" -t "%C%y%m%d%H%M.%S" "${target_file}")" ||

    mv    -f       "${source_file}"          "${target_file}" || { echo_log --level 'ERROR' 'Could not replace target file contents with source.' ; return $? ; }
    touch -c -m -t "${target_date_modified}" "${target_file}" || { echo_log --level 'WARNING' 'Could not reset target file modification date to pre-operation date.' ; }

    return 0
}


####
##  Add an extension to files whose extension is incorrect, using the 'file'
##  command to assess the file's type and valid extensions.
##
##  ARGUMENTS
##  ---------
##  --validate-only : Dry run.  Print matching files without modification.
##
##  $1: <description_pattern>  Pattern which will be tested against the output
##      of the 'file --brief' command for each input file.  If the output of
##      the 'file' command does not match this pattern, it will be skipped.
##
##  #2: <replacement_extension>  The desired extension to append to files which
##      which do not have a proper extension.  This value will be checked
##      against the list of valid extensions returned by 'file --extension'.
##
##  $3-$n: <input_file ...>  The path to the file(s) to be evaluated.  Multiple
##      file paths and glob patterns can be provided.
##
##  EXAMPLE
##  -------
##  For every file (not folder) in the current path: if it contains JPEG data
##  and does not have a proper extension, add the extension 'jpg' to the file.
##
##      % fix_extension 'JPEG*' 'jpg' ^*.*(.)
##
function fix_extension ()  # [--validate-only] <description_pattern> <replacement_extension> <input_file ...>
{
    typeset -i validate_only=0

    [[ "${1}" = '--validate-only' ]] &&
    {
        echo_log --level 'INFO' "Validating only... no modifications will be made."
        validate_only=1
        shift
    }

    [[ -n "${1}" ]] || { echo_log --level 'ERROR' "Argument for 'file --brief' match pattern is missing or empty" ; return 10 ; }
    typeset file_command_pattern="${1}"

    shift ; [[ -n "${1}" ]] || { echo_log --level 'ERROR' "Argument for replacement extension is missing or empty" ; return 30 ; }
    typeset replacement_extension="${1}"

    shift ; (( ${#@} )) || { echo_log --level 'ERROR' "Input file(s) missing or empty" ; return 40 ; }
    typeset -a input_files=( ${@} )

    for input_file ( ${input_files} )
    {
        input_file=${~"${input_file}"}

        # If the output of `file` doesn't match what we're looking for, skip to the next file.
        [[ "$(file --brief -- ${input_file})" != ${~file_command_pattern} ]] && continue

        # Use the `file` command to determine the valid extensions for the file.
        typeset -a valid_extensions=( ${(s:/:)$(file --brief --extension ${input_file})} )

        # If the file's extension matches one of the specified extensions, skip to the next file.
        { [[ -n "${input_file:e}" ]] && (( $valid_extensions[(I)(#i)${input_file:e}] )) } && continue

        echo_log --level 'INFO' "Input file '${input_file}' extension should be one of: '${(j', ')valid_extensions}'."

        (( $valid_extensions[(I)(#i)${replacement_extension}] )) ||
        {
            echo_log --level 'WARNING' "Specified replacement extension '${}' is not valid for this file type."
            continue
        }

        (( validate_only )) && continue

        echo_log --level 'INFO' --indent 1 --fill ' ' --spacer '-> ' "Changing extension to '${replacement_extension}'."
        mv -- ${input_file} "${input_file:r}.${replacement_extension}"
    }
}


####
##  Remove macOS-specific Finder metadata files, stored as files prefixed with '._'
##
function remove_finder_metadata_files ()  # [--recursive] [--dry-run]
{
    typeset working_path='.'
    typeset -a remove_cmd=( 'remove_existing' )
    typeset -a file_brief_cmd=( 'file' '--brief' )
    typeset file_brief_description='AppleDouble encoded Macintosh file'

    [[ "${1}" = '--recursive' ]] && { working_path='**' ; shift ; }
    [[ "${1}" = '--dry-run'    ]] && { remove_cmd='echo' ; }

    for macos_file ( ${~"${working_path}"}/._*(.N) )
    {
        [[ "$( "${file_brief_cmd[@]}" "${macos_file}" )" == "${file_brief_description}" ]] ||
        {
            echo_log --level 'INFO' "Not removing '${macos_file}' because '${file_brief_cmd}' does not describe it as '${file_brief_description}'."
            continue
        }

        "${remove_cmd[@]}" "${macos_file}"
    }
}


####
##  Print a recursive tree of files and folders from the given path.
##
function file_tree ()  # <start_path>
{
    typeset start_path=${~"${1}"}
    [[ -n "${start_path}" && -e "${start_path}" ]] || { echo_log --level 'ERROR' 'Argument for starting path is missing or empty, or nothing exists at the specified path.' ; return 10 ; }

    find "${start_path}" | sed -e 's/[^-][^\/]*\// |/g' -e 's/|\([^ ]\)/|-\1/'
}


####
##  Prompt the user for a password using a secure (non-echoed) input, and echo
##  the entered text back to stdout.
##
##  This should be used in a context which will capture the output so that
##  sensitive information is not displayed on screen.
##
##  EXAMPLES
##  -------
##  Add a password item to the Keychain:
##      % security add-internet-password -A -a 'username' \
##        -s 'secure.website.domain.net' -r 'htps' \
##        -w "$(ask_for_password)" 'login'
##
##  Provide a password to the `curl` command:
##      % curl --user v076726:$(ask_for_password) ...
##
function ask_for_password ()
{
    typeset password_input
    read -s 'password_input?Password:'
    echo $password_input
}


####
##  Create a new directory for temporary files.  The location will be:
##  * a uniquely named directory
##      * inside a directory named after the script
##          * inside a directory named with `$ORGANIZATION_ID`
##              * located either in `$TMPDIR` (if it is set) or `/tmp/`.
##
##  For example, if `$TMPDIR` is not set, and this function is called from a
##  script named `do_something_awesome.zsh`, the new directory's path could be:
##  > `/tmp/com.organization.it.mac-admin/do_something_awesome/0C4D2B82-C99D-4E1E-B71D-AD0577A8F507/`
##
function new_tmp_dir ()  # <purpose>
{
    typeset base_tmp_dir="${TMPDIR:-/tmp/}"
    typeset purpose="${1:-${ZSH_ARGZERO:t:r}}" # Use the script name if not set.

    [[ -n "${purpose}" ]] || { echo_log --level 'ERROR' 'Purpose for the temporary directory may not be empty.' ; return 1 ; }

    typeset unique_id="$( /usr/bin/uuidgen )"
    typeset new_tmp_dir_path="${base_tmp_dir}${ORGANIZATION_ID}/${purpose}.${unique_id}"

    echo_debug "Creating empty temporary directory for script-related task at '${new_tmp_dir_path}'..."

    /bin/mkdir -p  "${new_tmp_dir_path}" &&
        /bin/chmod 700 "${new_tmp_dir_path}" ||
            { echo_log --level 'ERROR' 'Unable to create or change mode on new temporary directory.' ; return $? ; }

    echo "${new_tmp_dir_path}"
}


##
##  Generate a "universally" formatted value for use with the global `no_proxy`
##  parameter for proxy bypass in the shell.  Output format will be governed by
##  the following guidelines and assumptions:
##
##  * Use lowercase form.
##  * Use comma-separated hostname:port values.
##  * IP addresses are okay, but hostnames are never resolved.
##  * Suffixes match without `*` (e.g. foo.com is the wildcard for *.foo.com).
##  * IP ranges in CIDR format (e.g.: 10/6) are not supported.
##
##  Reference:
##  https://about.gitlab.com/blog/2021/01/27/we-need-to-talk-no-proxy/
##
function user_proxy_convert_gui_bypass_to_noproxy ()
{
    typeset -a exception_list=()
    typeset scutil_path='/usr/sbin/scutil'

    [[ -x "${scutil_path}" && -f "${scutil_path}" ]] && exception_list=( $("${scutil_path}" --proxy | awk '/ExceptionsList : <array> {/,/}/  {if (/^[[:space:]]+[[:digit:]]+ : /) { $1="" ; $2="" ; print $3 }}') )
    # TODO: Support `gsettings` output, which looks like: ['localhost', '127.0.0.0/8', '::1', '*.local']

    # If the exception list is empty, bail.
    (( ${#exception_list} )) || return

    # `zsh` Parameter Expansion Explanation
    # -------------------------------------
    # Start with the array parameter name (`exception_list`), and work outward.
    # Operator  #\*.   : Strip the first instance of '.*' from all elements
    #                    (no_proxy disallows this form of wildcarding).
    # Operator  :#*/*  : Remove any element containing a slash
    #                    (`no_proxy` doesn't support CIDR IP ranges).
    # Flag      j','   : Join array elements into a single word using a comma.
    echo ${(j',')${exception_list#\*.}:#*/*}
}


####
##  Set, unset, or list all proxy parameters for the current environment.
##  With no action, print all proxy parameters.
##
##  ENVIRONMENT:
##  The following environment parameters will be observed by this function.
##  Observance conditions are documented for each parameter.
##
##  ${USER_PROXY_ENV_PARAMETERS} : An array containing the names of
##      parameters whose value will be set to [user_proxy_url].  This function
##      will automatically set the upper- and lower-case variant of each
##      parameter name (e.g., 'HTTP_PROXY' also sets 'http_proxy').
##      Default: ( 'HTTP_PROXY' 'HTTPS_PROXY' 'ALL_PROXY' )
##
##  ${USER_PROXY_ENV_PARAMETERS_NOPROXY} : An array containing the names of
##      parameters whose value will be set to [user_proxy_direct_hosts]. This
##      function will automatically set the upper- and lower-case variant of
##      each parameter name (e.g., 'NO_PROXY' also sets 'no_proxy').
##      Default: ( 'NO_PROXY' )
##
##  ${USER_PROXY_URL} : If [user_proxy_url] ($2) is unset or empty, this
##      environment variable will be checked for a URL value.  If set, the URL
##      will be used as the value when setting the parameter(s) specified by
##      ${USER_PROXY_ENV_PARAMETERS}.
##
##  ${USER_PROXY_DIRECT} : If [user_proxy_direct_hosts] ($3) is unset or empty,
##      this environment variable will be checked for an array of hosts for
##      which established connections should bypass the proxy.  If set, this
##      list will be joined with commas, and used as the value when setting the
##      parameter(s) specified by ${USER_PROXY_ENV_PARAMETERS_NOPROXY}.
##
##  AUTOMATIC PROXY BYPASS GENERATION:
##  If neither [user_proxy_direct_hosts] ($3) or ${USER_PROXY_DIRECT} are set,
##  this function will call the user_proxy_convert_gui_bypass_to_noproxy()
##  function to generate the direct host list from the system-wide
##  proxy configuration.
##
function user_proxy ()  # [set | unset | script | list] [user_proxy_url] [user_proxy_direct_hosts]
{
    ## Action must be empty, or one of the actions in this array.
    typeset -a actions=( 'set' 'unset' 'script' 'list' )
    typeset action="${1}"
    [[ -z "${action}" ]] || (( ${actions[(Ie)$action]} )) || { echo_log --level 'ERROR' "Specified action must be one of: (${(j', ')actions})." ; return 10 ; }

    typeset -a proxy_env_param_names=( ${USER_PROXY_ENV_PARAMETERS} )
    (( $#proxy_env_param_names )) || proxy_env_param_names=(
        'HTTP_PROXY'
        'HTTPS_PROXY'
        'ALL_PROXY'
    )

    typeset -a proxy_env_param_names_noproxy=( ${USER_PROXY_ENV_PARAMETERS_NOPROXY} )
    (( $#proxy_env_param_names_noproxy )) || proxy_env_param_names_noproxy=(
        'NO_PROXY'
    )

    typeset -a all_param_names=( ${proxy_env_param_names} ${proxy_env_param_names_noproxy} )

    ##  ACTION: 'list' (default)  ##############################################
    ##  Print user-friendly report of current proxy environment configuration.
    [[ -z "${action}" || "${action}" == 'list' ]] &&
    {
        typeset -i max_name_length=${${(ONn)all_param_names%%*}[1]}
        for param_name ( ${all_param_names} ) { echo "${(r:$max_name_length:)param_name:u} ${(r:$max_name_length:)param_name:l} ${(P)param_name}" }
        return 0
    }

    function _unset_user_proxy_params ()
    {
        echo_debug 'Un-setting all proxy-related environment parameters.'
        for param_name ( ${all_param_names:u} ${all_param_names:l} )
        {
            echo_debug "Unsetting parameter: '${param_name}'..."
            unset "${param_name}"
        }
    }

    ##  ACTION: 'unset'  #######################################################
    ##  Un-set all proxy configuration parameters in the current environment.
    [[ -z "${action}" || "${action}" == 'unset' ]] &&
    {
        _unset_user_proxy_params
        unset -f _unset_user_proxy_params
        return 0
    }

    ##  The proxy URL is needed for all remaining actions.  Exit if not set.
    typeset proxy_url="${2}"
    [[ -n "${proxy_url}" ]] || proxy_url="${USER_PROXY_URL}"
    [[ -n "${proxy_url}" ]] || { echo_log --level 'ERROR' "No proxy URL was provided." ; return 20 ; }

    ##  Also, show warning if the bypass hosts are not set.
    typeset noproxy_value="${(j:,:)USER_PROXY_DIRECT}"
    [[ -n "${noproxy_value}" ]] || noproxy_value="$( user_proxy_convert_gui_bypass_to_noproxy )"
    [[ -n "${noproxy_value}" ]] || echo_log --level 'WARNING' "The 'NO_PROXY' environment variable could not be set automatically for this shell session."

    ##  ACTION: 'script'  ######################################################
    ##  Print shell script (zsh) which can be evaluated to enable the proxy.
    [[ "${action}" == 'script' ]] &&
    {
        for param         ( ${proxy_env_param_names:u}         ${proxy_env_param_names:l} )         echo "typeset -gx ${param}='${proxy_url}'"
        for noproxy_param ( ${proxy_env_param_names_noproxy:u} ${proxy_env_param_names_noproxy:l} ) echo "typeset -gx ${noproxy_param}='${noproxy_value}'"
        return 0
    }

    ##  ACTION: 'set'  #########################################################
    ##  Set all proxy configuration parameters in the current environment.
    [[ "${action}" == 'set' ]] &&
    {
        _unset_user_proxy_params

        echo_debug "Setting proxy URL for current environment to '${proxy_url}'."
        for param ( ${proxy_env_param_names:u} ${proxy_env_param_names:l} ) typeset -gx "${param}"="${proxy_url}"

        echo_debug "Setting no-proxy bypass for current environment to '${noproxy_value}'."
        for noproxy_param ( ${proxy_env_param_names_noproxy:u} ${proxy_env_param_names_noproxy:l} ) typeset -gx "${noproxy_param}"="${noproxy_value}"

        return 0
    }

    unset -f _unset_user_proxy_params
}


####
##  Read the contents for the given AuthorizationDB right, formatted as an
##  XML property list.
##
function authdb_read ()  # <right_name>
{
    typeset right_name="${1}"
    echo_debug "Reading AuthorizationDB right '${right_name}'..."

    eval "$( ( /usr/bin/security authorizationdb read "${right_name}" ) \
            2> >(read_status=$(cat); typeset -p read_status) \
            > >(right_contents=$(cat); typeset -p right_contents); result_code=$?; typeset -p result_code )"

    (( result_code > 0 )) && { echo_log --level 'ERROR' "Unable to read right '${right_name}'.  Error: '${read_status}'." ; return result_code ; }

    echo_debug "Contents of right '${right_name}' are as follows:\n${right_contents}"
    echo_debug "Read Status: '${read_status}'"
    echo "${right_contents}"
}


####
##  Update the contents of the given AuthorizationDB right.
##
##  The updated content can be specified as either a single rule (provided via
##  the second argument), or as an XML property list (provided via stdin).
##
function authdb_write ()  # <right_name> [rule_id | plist-content-via-stdin]
{
    typeset right_name="${1}"
    typeset rule_id="${2}"

    ###############################################################
    ## PATH 1 - UPDATE RIGHT TO DELEGATE TO rule_id SPECIFIED IN $2
    [[ -n "${rule_id}" ]] &&
    {
        echo_debug "Updating AuthorizationDB right to invoke rule '${rule_id}'..."
        /usr/bin/security authorizationdb write "${right_name}" "${rule_id}" ||
        {
            echo_log --level 'ERROR' "Unable to update right '${right_name}'; the AuthDB 'write' operation failed."
            return 1
        }

        return 0
    }

    ###############################################
    ## PATH 2 - UPDATE RIGHT WITH CONTENTS OF STDIN
    echo_debug "Updating AuthorizationDB right '${right_name}' with Plist contents from stdin..."

    typeset right_contents && right_contents="$( [[ -t 0 ]] || cat - )"  ||
    {
        echo_log --level 'ERROR' "Unable to update right '${right_name}'; no Plist content was provided via stdin."
        return 1
    }

    echo_debug "Updated contents of right '${right_name}' will be as follows:\n\n${right_contents}\n"

    echo "${right_contents}" | /usr/bin/security authorizationdb write "${right_name}" ||
    {
        echo_log --level 'ERROR' "Unable to update right '${right_name}'; the AuthDB 'write' operation failed."
        return $?
    }
}


####
##  Remove an AuthorizationDB right.
##
function authdb_remove ()  # [--bypass-system-right-restriction] <right_name>
{
    typeset system_removal_flag='--bypass-system-right-restriction'
    typeset -i system_removal_enabled=0
    [[ "${1}" == "${system_removal_flag}" ]] && { system_removal_enabled=1 ; shift ; }

    typeset right_name="${1}"

    #################################################################
    ## HAPPY PATH: REMOVE NON-"system.*" RIGHT USING 'security' TOOL.

    [[ "${right_name}" != 'system.'* ]] &&
    {
        echo_debug "Removing right '${right_name}' from the AuthorizationDB..."

        /usr/bin/security authorizationdb remove "${right_name}" ||
        {
            echo_log --level 'ERROR' "Unable to remove right '${right_name}' from the AuthDB."
            return $?
        }

        return 0
    }

    ##########################################################################
    ## TREACHEROUS PATH: REMOVE "system.*" RIGHT BY EDITING 'auth.db' DIRECTLY

    (( system_removal_enabled )) ||
    {
        echo_log --level 'ERROR' "Rights which begin with 'system.' may not be removed without enabling system right removal."
        echo_log --level 'ERROR' "You can forcibly remove the right named '${right_name}' by adding the '${system_removal_flag}' flag to this command."
        echo_log --level 'ERROR' "PLEASE NOTE: Using this flag will sidestep Apple's logic, and edit the AuthorizationDB directly using SQLite commands."
        echo_log --level 'ERROR' "This is highly undesirable, and should be avoided in standard practice."
        return 1
    }

    typeset authdb_file='/private/var/db/auth.db'
    typeset -a sqlite_cmd=('/usr/bin/sqlite3' '-bail' "${authdb_file}")
    typeset -i right_id

    echo_log "Bypassing Apple's logic to remove right '${right_name}' from the AuthorizationDB using SQLite commands."
    echo_log --level 'WARNING' "This is highly undesirable, and should be avoided in standard practice."

    # VERIFY THAT A RULE EXISTS IN THE AUTH DB WITH THE SPECIFIED NAME.
    # RESTRICT QUERY TO "RIGHT" RULES ONLY (type = 1).  GRAB VALUE.
    right_id=$( "${sqlite_cmd[@]}" "SELECT id FROM rules WHERE name = '${right_name}' AND type = 1;" ) && (( right_id > 0 )) ||
    {
        echo_log --level 'ERROR' "Unable to find right with name '${right_name}' in the Authorization DB."
        return 1
    }

    echo_debug "Right named '${right_name}' has ID '${right_id}' in the Authorization DB."

    typeset -a modification_query=(
        'PRAGMA    foreign_keys = ON;'
        'PRAGMA    temp_store   = MEMORY;'
        'PRAGMA    auto_vacuum  = FULL;'
        'PRAGMA    journal_mode = WAL;'
        '.filectrl persist_wal    ON'
        "DELETE FROM rules WHERE id = ${right_id};"
    )

    echo_debug "Executing database query:\n    ${(j'\n    ')modification_query}\n"
    echo "${(j'\n')modification_query}" | "${sqlite_cmd[@]}" ||
    {
        echo_log --level 'ERROR' "SQLite query failed with status '$?'.  Right '${right_name}' will not be removed."
        return $?
    }

    return 0
}


####
##  Reset the configuration of the the given AuthorizationDB right to its
##  "factory-default" state, as provided by the SIP-protected reference at
##  `/System/Library/Security/authorization.plist`.
##
function authdb_factory_reset ()  # <right_name>
{
    typeset right_name="${1}"
    typeset factory_config_file='/System/Library/Security/authorization.plist'

    echo_debug "Resetting AuthorizationDB right '${right_name}' to its factory-default configuration from '${factory_config_file}'..."

    typeset factory_contents && factory_contents=$( /usr/libexec/PlistBuddy -x -c "Print :rights:${right_name}" "${factory_config_file}" )  ||
    {
        echo_log --level 'ERROR' "Unable to fetch factory state for right '${right_name}'."
        return $?
    }

    echo "${factory_contents}" | authdb_write "${right_name}"
}


####
##  Returns launchd domain target for the local user's GUI session.
##
function launchd_local_user_domain_target ()
{
    echo "gui/$( user_id_for_name $( local_user_name ) )"
}


####
##  Boot out a list of launchd service targets.
##  A service target is the domain target (e.g., 'system' or 'gui/<UID>')
##  and the service name ('com.foo.bar'), seperated by a slash.
##
function launchd_boot_out_service_targets ()  # <service-target [...]>
{
    typeset -a service_targets=( $@ )
    typeset launch_service
    typeset -i launchctl_status

    for service_target ( ${service_targets} )
    {
        echo_debug "Booting out launchd service target '${service_target}'..."
        /bin/launchctl bootout "${service_target}" ||
        {
            launchctl_status=$?

            # If launchctl exits with status 3 (No such process; i.e., not
            # bootstrapped), continue normally.  Otherwise, return the status
            # from launchctl.
            (( launchctl_status == 3 )) && { echo_log --level 'INFO' "Service target '${service_target}' is not bootstrapped.  Skipping...'" ; continue ; }

            return ${launchctl_status}
        }
    }

    return 0
}


####
##  Boot out a list of system-level launchd service targets with the specified
##  service names.  The 'system' domain target will be prefixed for you.
##
function launchd_boot_out_system_services_named ()  # <service-name-in-system-domain [...]>
{
    launchd_boot_out_service_targets ${@/#/system/}
}


####
##  Boot out a list of launchd service targets associated with the current
##  user's GUI launchd session.  The 'gui/<UID>' domain target will be
##  prefixed for you.
##
function launchd_boot_out_user_services_named ()  # <service-name-in-user-domain [...]>
{
    launchd_boot_out_service_targets ${@/#/$(launchd_local_user_domain_target)/}
}


####
##  WIP
##  Remove parenthetically unique duplicates of a file by comparing their
##  contents and deleting identical files.
##
function remove_duplicates ()  # --dry-run
{
    typeset original_by_name
    typeset -a remove_cmd=( 'remove_existing' )

    [[ "${1}" = '--dry-run' ]] && { remove_cmd=( 'echo' 'DRY RUN - Not removing: ' ) ; shift ; }

    typeset stub
    typeset ext
    typeset original_by_name

    # Glob: all items ending in '(n)' or '(n).ext' where n is an integer; zero results is fine.
    for duplicate_candidate ( *\(<1->\)(.*)#(N) )
    {
        stub="${duplicate_candidate:r}"
        ext="${duplicate_candidate:e}"

        [[ -n "${ext}" ]] && ext=".${ext}"

        case "${duplicate_candidate}" in
            *\(1\)(.*)#) # (1): remove the number and parens entirely
                original_by_name="${${duplicate_candidate:r}/%\(1\)/}${ext}"
                ;;
            *) # (2+): decrement the number
                echo twoplus
                ;;
        esac

        continue

        echo_log -n --level 'INFO' "Found '${duplicate_candidate}'... "

        original_by_name="${${duplicate_candidate:r}/%\(<1->\)/}.${duplicate_candidate:e}"
        [[ -f "${original_by_name}" ]] ||
        {
            echo_err "⏭️  Skipped: no corresponding original filename found."
            continue
        }

        echo_err -n "Comparing to '${original_by_name}'... "
        cmp --silent "${duplicate_candidate}" "${original_by_name}" ||
        {
            echo_err "⏭️  Skipped: not equivalent."
            continue
        }

        echo_err "🗑️  Removing as duplicate."
        "${remove_cmd[@]}" "${duplicate_candidate}"
    }
}


####
##  Poll the pasteboard's contents, and run a command when it is modified.
##
##  TEMPLATE PLACEHOLDER
##  If command or arguments contain the substring '<PASTE>', that subtring will
##  be replaced by the pasteboard's contents.
##
# function when_pasteboard_changes ()  # [--one-run-only] [--interval <seconds>] command_template [arg_template ...]
# {
#     zmodload zsh/zutil || return 1

#     ## Create usage output.
#     typeset usage=(
#         "$0 [--help]"
#         "$0 [--one-run-only] [--interval <seconds>] command_template [arg_template ...]"
#     )

#     ## Define parameter defaults.
#     typeset -a flag_help=( $( (( $# > 0 )) || echo "NO_ARGS" ) )
#     typeset -a flag_once=( )
#     typeset    default_interval='5'
#     typeset -a arg_interval=( ${default_interval} )

#     ## Parse function arguments.
#     zparseopts -D -F -K -- \
#         -help=flag_help \
#         -one-run-only=flag_once \
#         -interval:=arg_interval \
#     || return 1

#     ## Display usage if help flag is set, or if no command was provided.
#     (( ${#flag_help} || (! ${#@}) )) && { print -l $usage && return 0 ; }

#     typeset -F 4 interval=$(( ${arg_interval[-1]} ))
#     (( interval )) || interval=${default_interval}

#     while ( true ) { echo "$@" ; sleep "${interval}" ; }
# }

# function when_pasteboard_changes ()  # [--every <seconds>] command_template [arg_template ...]
# {
#     ## Create usage output.
#     typeset usage=(
#         "$0 [--help]"
#         "$0 [--every <seconds>] command_template [arg_template ...]"
#     )

#     zmodload zsh/zutil || return 1
#     typeset -a flag_help=()
#     typeset -a arg_every=()
#     zparseopts -D -F -K -- \
#         -help=flag_help \
#         -every:=arg_every \
#     || return 1

#     ## Display usage if help flag is set, or if no command was provided.
#     (( ${#flag_help} || (! ${#@}) )) && { print -l $usage && return 0 ; }

#     typeset -U array_every=( ${(ps::)arg_every[-1]} )
#     (( ${#array_every} == 1 )) && [[ "" ]]

#     # Cast the specified 'every' interval to a float.
#     typeset -F 4 interval=$(( ${arg_every[-1]} ))

#     # If the interval is less than zero, prepare to execute only once.
#     typeset -a return_if_interval_lt_zero=()
#     (( interval < 0 )) && { return_if_interval_lt_zero=( 'return' '0' ) }

#     while ( true )
#     {
#         #if the pasteboard value has changed
#         {
#             echo "$@"
#             ${return_if_interval_lt_zero}
#             sleep "${interval}"
#         }
#     }
# }


####
##  Download a large file, broken into chunks of a specified size in megabytes
##  (default is 20).
##
# function download_chunked ()  # <remote_url> <output_file_path> <chunk_size=20>
# {
#     typeset -i chunk_size
#
#     typeset dl_command="curl"
#
#     typeset remote_url="${1}"       ; [[ -n "${remote_url}" ]]       || fail 'Argument for remote URL is missing or empty.' 10
#     typeset output_file_path="${2}" ; [[ -n "${output_file_path}" ]] || fail 'Argument for output path is missing or empty.' 20

#     # Check output path's last directory exists, or fail
#     # Check output path's last directory is writable, or fail

#     typeset chunk_input="${3}" ; [[ "${chunk_size}" == <-> ]] || { chunk_input='' ; echo "Specified chunk size is not valid.' INFO }
#     (( chunk_size = $chunk_input )) ; [[ "${chunk_size}" == <-> && -n "${chunk_size}" ]] || echo 'Using default chunk size of 20 MB.' INFO
#     # Check that chunk size is a non-zero integer, or log that the default will be used
#
#
# }

