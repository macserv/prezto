##
##  ZSHRC EXTENSION:
##  Functions: Common
##


################################################################################
##  SHARED / HELPERS

####
##  "Comment" a line of text in a way that is visible in a list of commands.
##  This function does nothing, and does not make use of the arguments passed to
##  it.  The arguments are ignored, and can be used to make a general comment.
##
##  This differs from '#' in that comments following '//' will appear in the
##  listing of a function's script as reported by commands like 'which'.
##
##  Caveat: The comment words are arguments to the function named '//'.  Unlike
##      a normal comment created by using the '#' character, the "commenting"
##      effect of '//' ends at a control structure (e.g., ';', '&&', parentheses
##      or braces, etc.).
##
##  EXAMPLE 1
##  ---------
##  % function comment_hash () { # comment, yo! }
##  function>
##  # The octalthorpe character prevented the closing brace from being
##  # interpreted, so zle is now expecting more lines.
##
##  EXAMPLE 2
##  ---------
##  % function comment_hash () {
##  function>     # comment, yo!
##  function> }
##  % which comment_hash
##  comment_hash () {
##
##  }
##  # Normal '#' comments are not stored when a function is created, so they
##  # can't be seen in the output of 'which'.
##
##  EXAMPLE 3
##  ---------
##  % function comment_slash () { // comment, yo! }
##  % which comment_slash
##  comment_slash () {
##      // comment, yo!
##  }
##  # The slashed command is included in 'which` output.
##
function // ()  # [comment_word ...]
{
    # Function intentionally empty.
}


####
##  Echo to StdErr instead of StdOut.
##
function echo_err ()  # [-n] words ...
{
    typeset echo_cmd='echo'
    [[ "${1}" == "-n" ]] && { echo_cmd="${echo_cmd} -n" ; shift ; }
    "${echo_cmd}" $@ 1>&2
}


####
##  Echo to StdErr instead of StdOut, but only when $ENABLE_ECHO_DEBUG is
##  greater than zero.
##
function echo_err_debug ()  # [-n] words ...
{
    (( ENABLE_ECHO_DEBUG )) && { echo_err $@ ; }
}


####
##  Echo a log message with consistent formatting, including tracing info and
##  a message prefix based on the severity of the message.
##
##  OUTPUT FILE DESCRIPTOR
##  ----------------------
##  Messages generated by 'echo_log' are sent to 'stderr' so that they do not
##  interfere with the functionality of functions which print text to 'stdout'
##  which is intended for consumption by a calling function.
##
##  ARGUMENTS
##  ---------
##  --transparent : Make the caller transparent; that is, ignore the calling
##      function, and report its parent instead.  This is useful when you want
##      to "transparently" wrap `echo_log` in another logging function without
##      it being displayed as the caller.
##
##  $1: <message>  The message to be logged.  To read this from stdin, use '--'.
##  $2: [log_type]  Optional. Can be any of the following.
##
##      Type     | Sample
##      ----------------------------------
##      ERROR    | "[ERROR] <message>"
##      WARNING  | "[WARNING] <message>"
##      INFO     | "[INFO] <message>"
##      DEBUG    | "[DEBUG] <message>"
##      <custom> | "[<custom>] <message>"
##      (none)   | "<message>"
##
##  $3: [indent_level]  Optional.  The number of indentation levels which should
##      precede the message.  Default: 0.
##  $4: [fill]  Optional.  The string which will be repeated to fill the
##      indented space.  Default: spaces will be used as fill.
##  $5: [spacer]  Optional.  A string which will replace the filler immediately
##      before the message.  Default: none.
##
##  STATUS PASS-THROUGH
##  ---------------------
##  The 'echo_log' command will return the same status as the command which was
##  executed immediately beforehand.
##
##  ENVIRONMENT VARIABLES
##  ---------------------
##  ${ECHO_LOG_INDENT_SPACES}: If this parameter is set to an non-negative
##      integer value, it will be used to determine the number of spaces
##      leading the message for each level of indentation.
##      Default: 4.
##
##  SUPPRESSING TRAILING NEWLINE
##  ----------------------------
##  The log message will end with a newline ('\n') character, causing a
##  line-feed and carriage return after printing.  To prevent this default
##  behavior, a '\c' (escape) character can be added to the end of the specified
##  message string, which will suppress the addition of the newline, allowing
##  more characters to be appended to the same line in the shell.
##
##  LOG MESSAGE TRACE PREFIX
##  ------------------------
##  Each log message is prefixed with the following three details, useful for
##  tracing script execution:
##      * The base name of the script being executed.
##            * If `echo_log` is invoked on the command line, this will be the
##              name of the shell (e.g. 'zsh').
##            * If `echo_log` is invoked from within a function created on the
##              command line, this will be empty.
##      * The line number of the `echo_log` statement within the script.
##            * If `echo_log` is invoked on the command line, this represents
##              the history event of the command.
##      * The function within which `echo_log` was called.  If function calls
##        are nested, this is the function nearest the top of the stack.
##            * If `echo_log` is invoked within an anonymous function, this will
##              report as `(anon)` (as of zsh 5.8.1).
##
##  EXAMPLE
##  -------
##  function test_logs ()
##  {
##      echo_log
##      echo_log '' INFO
##      echo_log 'Info message.' INFO
##      echo_log 'Warning message.' WARNING
##      echo_log 'Error message!' ERROR
##      echo_log 'Debug message, unindented.' DEBUG
##      echo_log 'Debug message, indented once, supressing newline... \c' DEBUG 1
##      echo_err 'until now!'
##      echo_log 'Debug, indented 2 times, with dash fill and final space.' DEBUG 2 '-' ' '
##      echo_log 'Debug, indented 2 times, with space fill and final arrow.' DEBUG 2 ' ' '-> '
##      echo_log 'Debug, indented 3 times, with alternating dots and spaces.' DEBUG 3 '. '
##      echo_log 'Debug, indented 4 times, with dots in groups of three.' DEBUG 4 '... '
##      function { echo_log 'Anonymous invocation with custom 'HACK' log type.' HACK }
##      echo "Message from stdin with custom 'PASS' type." | echo_log -- PASS
##      echo_err
##  }
##
##  EXAMPLE OUTPUT (after copying the above function to the pasteboard)
##  -------------------------------------------------------------------
##  % pbpaste >! $TMPDIR/logtest.zsh
##  % source $TMPDIR/logtest.zsh
##  % test_logs
##  [logtest.zsh:3(test_logs)]
##  [logtest.zsh:4(test_logs)] [INFO]
##  [logtest.zsh:5(test_logs)] [INFO] Info message.
##  [logtest.zsh:6(test_logs)] [WARNING] Warning message.
##  [logtest.zsh:7(test_logs)] [ERROR] Error message!
##  [logtest.zsh:8(test_logs)] [DEBUG] Debug message, unindented.
##  [logtest.zsh:9(test_logs)] [DEBUG]     Debug message, indented once, supressing newline... until now!
##  [logtest.zsh:11(test_logs)] [DEBUG] ------- Debug, indented 2 times, with dash fill and final space.
##  [logtest.zsh:12(test_logs)] [DEBUG]      -> Debug, indented 2 times, with space fill and final arrow.
##  [logtest.zsh:13(test_logs)] [DEBUG] . . . . . . Debug, indented 3 times, with alternating dots and spaces.
##  [logtest.zsh:14(test_logs)] [DEBUG] ... ... ... ... Debug, indented 4 times, with dots in groups of three.
##  [logtest.zsh:15((anon))] [HACK] Anonymous invocation with custom HACK log type.
##  [logtest.zsh:16(test_logs)] [PASS] Message from stdin with custom 'PASS' type
##  % echo_log "Direct invocation on command line with custom 'OK' type." OK
##  [-zsh:4] [OK] Direct invocation on command line with custom 'OK' type.
##
function echo_log ()  # [--transparent] <message> [log_type] [indent_level] [fill] [spacer]
{
    typeset -i passthrough_status=$?
    typeset -i transparent=0
    [[ "${1}" == "--transparent" ]] && { transparent=1 ; shift ; }

    typeset message="${1}"
    [[ "${message}" == '--' ]] && read -r message

    typeset prefix
    case $2 in
        ERROR)   prefix="[ERROR]"      ;;
        WARNING) prefix="[WARNING]"    ;;
        INFO)    prefix="[INFO]"       ;;
        DEBUG)   prefix="[DEBUG]"      ;;
        *)       prefix="${2:+[${2}]}" ;;
    esac

    typeset -i indent_level=$3
    (( indent_level )) &&
    {
        typeset -i indent_spaces=${ECHO_LOG_INDENT_SPACES:-4}
        (( indent_spaces < 0 )) && indent_spaces=0

        typeset -i message_length=$(( ${#message} + (${indent_level} * ${indent_spaces}) ))
        typeset filler="${4:- }"
        typeset spacer="$5"

        [[ -n "$spacer" ]] &&
            { message=${(pl:$message_length::$filler::$spacer:)message} ; } ||
            { message=${(pl:$message_length::$filler:)message} ; }
    }

    typeset -i file_trace_index=1
    typeset -i func_stack_index=2

    # Workaround for issue which causes an entry to be added to the top of the
    # file trace when an anonymous function calls 'echo_log' from a function
    # within a file which has been 'source'd, not executed directly.
    [[ "${funcfiletrace[$file_trace_index]}" == ':'* ]] && { file_trace_index+=1 }

    # If the '--transparent' flag is set, look one index higher in the stack
    # and file trace arrays to functionally ignore the caller.
    (( transparent )) &&
    {
        file_trace_index+=1
        func_stack_index+=1
    }

    typeset file=${funcfiletrace[$file_trace_index]##*/}
    typeset func=${funcstack[$func_stack_index]}

    typeset output="[${file:+"$file"}${func:+"($func)"}]${prefix:+ ${prefix}}${message:+ ${message}}"
    echo_err "${output}"

    return ${passthrough_status}
}


####
##  Echo a debug message, using the 'echo_log' mechanism, which will only be
##  printed if debug echo is enabled (see GLOBAL PARAMETERS).
##
##  The log type will be set to '[DEBUG]', and the '--transparent' flag will be
##  enabled automatically.
##
##  SEE ALSO: `echo_log`
##  --------------------
##  This function is a wrapper around the `echo_log` function.  Please refer to
##  the documentation for 'echo_log' to find additional details about the
##  arguments and environment variables affectring its behavior.
##
##  ARGUMENTS
##  ---------
##  $1: <message>
##  $2: [indent_level]  Optional.  Default: 0.
##  $3: [fill]  Optional.  Default: space.
##  $4: [spacer] Optional.  Default: none.
##
##  STATUS PASS-THROUGH
##  ---------------------
##  The 'echo_debug' command will return the same status as the command which
##  was executed immediately beforehand.
##
##  ENVIRONMENT VARIABLES
##  ---------------------
##  ${ENABLE_ECHO_DEBUG}: This parameter must be set to an integer greater
##      than zero for messages to be printed to the console.
##
function echo_debug ()  # <message> [indent_level] [fill] [spacer]
{
    typeset -i passthrough_status=$?

    (( ENABLE_ECHO_DEBUG )) || return 0

    typeset message="${1}"
    [[ "${message}" == '--' ]] && read -r message

    echo_log --transparent "${message}" DEBUG "$2" "$3" "$4"

    return ${passthrough_status}
}


####
##  Print a consistently-formatted log message useful for tracing a failure,
##  and issue an additional `return` command (with customizable status code)
##  in the environment where `fail` was called.
##
##  ARGUMENTS
##  ---------
##  $1: [message]  Optional.  The message to be displayed.
##  $2: [status]  Optional.  The status code to be returned by the function.
##
##  EXAMPLE
##  -------
##  This single line...
##
##      eject_warp_core || fail "Ejector systems off-line ($?)." $?
##
##  ... is equivalent to this...
##
##      eject_warp_core
##      eject_status=$?
##      if [ eject_status -neq 0 ] ; then
##          echo_log "Ejector systems off-line (${eject_status})." FAIL
##          return $eject_status
##      fi
##
##  FUNCTION "EXIT" BEHAVIOR
##  ------------------------
##  The extra `return` command issued by the `fail` function is designed to end
##  execution of a function immediately, and return control to the calling
##  (parent) environment.  Similarly, if used in a "one-liner", list of
##  commands, none of the commands after `fail` will be executed.
##
##  In cases where it would be helpful to supress this behavior (e.g., testing
##  and debugging), prevent this behavior, a subshell can be used to allow
##  execution to continue.  For example:
##      % fail 'Bar' || echo 'Baz'
##      [-zsh:1] [FAIL] Bar
##      % ( fail 'Bar' ) || echo 'Baz'
##      [-zsh:2] [FAIL] Bar
##      Baz
##
function fail ()  # [message] [status]
{
    typeset fail_message="${1:-An error ${2:+(${2}) }occurred.}"
    typeset fail_status=${2:-1}

    trap "echo_log ${(qq)fail_message} FAIL ; return ${fail_status}"  EXIT

    return 0
}


####
##  Get the user name of the user associated with this system.
##
function local_user_name ()
{
    user_most common
}


####
##  Get the UID for the system's local user.
##
function local_user_uid ()
{
    /usr/bin/id -u $(local_user_name)
}


####
##  Get the local home directory for the system's local user.
##
function local_user_home ()
{
    /usr/bin/dscl -plist '.' -read "/Users/$(local_user_name)" | /usr/bin/plutil -extract 'dsAttrTypeStandard:NFSHomeDirectory.0' raw -
}


####
##  Extract the value of the given keypath from a JSON object string.
##
##  NOTE: This uses the `plutil` command, whose JSON-handling capability is
##  undocumented, and may disappear without notice.
##
function value_for_keypath_in_json ()  # <keypath> <json_string>
{
    typeset keypath="${1}"
    typeset json_string="${2}"

    [[ -z "${keypath}" || -z "${json_string}" ]] &&
    {
        echo_log "Missing input for either the key to be extracted or the JSON object." ERROR
        return 1
    }

    echo "${json_string}" | plutil -extract "${keypath}" raw -
}


####
##  Present a GUI alert with a single button to let the user know that
##  an error has occurred.
##
##  OUTPUT
##  ------
##  The button which was clicked, e.g.: "buttonReturned:OK"
##
##  ARGUMENTS
##  ---------
##  $1: [message]  Optional.  The "message" to be shown in the alert.
##  $2: [title]  Optional.  The alert title.  Default: "An error occurred".
##  $3: [button_label]  Optional.  The button label.  Default: "OK".
##
##  EXAMPLES
##  --------
##  alert_dialog 'Nothing too serious'
##  alert_dialog 'You do not have the correct permissions to do this.' \
##               'Could not create user'
##  alert_dialog 'KLINGONS OFF THE STARBOARD BOW, CAPTAIN' \
##               'RED ALERT' \
##               'BATTLE STATIONS'
##
function display_alert_dialog ()  # <message> <title> <button_label>
{
    typeset message="$1"
    typeset title="${2:-An error occurred.}"
    typeset button_label="${3:-OK}"

    echo_debug "Displaying alert dialog to user with title: '${title}' / '${message}' / [${button_label}]"

    /usr/bin/osascript 2>/dev/null <<EOAPPLESCRIPT

        tell application "System Events"
            tell process "SystemUIServer"
                display alert "$title" as critical \
                    message "$message" \
                    buttons { "$button_label" } \
                    default button "$button_label"
            end tell
        end tell

EOAPPLESCRIPT
}


####
##  Present a notification in the notification center.
##
##  ARGUMENTS
##  ---------
##  $1: <message>  The "message" to be shown in the notification.
##  $2: [title]  Optional.  The notification's title.  Default: "Notification"
##  $3: [subtitle]  Optional.  The notification's subtitle.
##
function display_notification ()  # <message> <title> <button_label>
{
    [[ -n "${1}" ]] || { fail "A message must be provided for the notification."}

    echo_debug "Displaying notification to user with message '${message}', title '${2}', subtitle '${3}'."

    /usr/bin/osascript 2>/dev/null <<EOAPPLESCRIPT

        tell application "System Events"
            tell process "SystemUIServer"
                display notification "${1}" with title "${2:-Notification}" subtitle "${3}"
            end tell
        end tell

EOAPPLESCRIPT
}


####
##  Present a GUI selection user interface to allow the user to choose from a
##  list of available options.
##
##  OUTPUT
##  ------
##  The item which was selected.
##
##  ARGUMENTS
##  ---------
##  $1: [title]  The list title.
##  $2: [message]  The message prompting to select an item.
##  $3-$n: [item ...]  The items which will appear in the list.
##
##  RETURN STATUS
##  -------------
##  0: An item was chosen normally.
##  10: The "Cancel" button was clicked.
##
function select_from_list_dialog ()  # [title] [message] [item] ...
{
    typeset title="$1"
    typeset message="$2"
    typeset -a items=( ${@:3} )
    typeset -a quoted_items=${(j[, ])${(qqq)items[@]}}

    echo_debug "Displaying alert dialog to user: '${title}' / '${message}' / [ ${quoted_items} ]"

    typeset selected_item ; selected_item=$( /usr/bin/osascript 2>/dev/null <<EOAPPLESCRIPT

        tell application "System Events"
            tell process "SystemUIServer"
                activate
                set listOptions to { $quoted_items }
                choose from list listOptions \
                    with title "$title" \
                    with prompt "$message" \
                    OK button name "OK" \
                    cancel button name "Cancel"
            end tell
        end tell

EOAPPLESCRIPT
    )

    [[ "${selected_item}" == "false" ]] && return 10

    echo "${selected_item}"
}


####
##  Silently determine if a user is a member of a given group.
##
##  ARGUMENTS
##  ---------
##  $1: <user_name>  The name of the user to be verified.
##  $2: <group_name>  The group which is to be checked for membership.
##
##  Return Codes:
##        0: The user is a member of the given group.
##      121: Argument for user name is missing or empty.
##      122: Argument for group name is missing or empty.
##        n: The user is not a member of the given group, or the membership
##           check failed, `dseditgroup` code returned.
##
function check_user_for_group_membership ()  # <user_name> <group_name>
{
    typeset user_name="${1}"  ; [[ -n "${user_name}"  ]] || return 121
    typeset group_name="${2}" ; [[ -n "${group_name}" ]] || return 122

    echo_debug "Checking whether '${user_name}' is a member of '${group_name}'..."
    /usr/sbin/dseditgroup -o checkmember -m "${user_name}" "${group_name}" >/dev/null
}


####
##  Silently attempt to add a user to the specified group.
##
##  ARGUMENTS
##  ---------
##  $1: <user_name>  The name of the user to be added to the group.
##  $2: <group_name>  The group to which the user should be added.
##
##  Return Codes:
##        0: The user was added successfully.
##      121: Argument for user name is missing or empty.
##      122: Argument for group name is missing or empty.
##        n: The operation to add the user failed; returns `dseditgroup` status.
##
function add_user_to_group ()  # <user_name> <group_name>
{
    typeset user_name="${1}"  ; [[ -n "${user_name}"  ]] || return 121
    typeset group_name="${2}" ; [[ -n "${group_name}" ]] || return 122

    check_user_for_group_membership "${user_name}" "${group_name}" && return 0

    echo_debug "Adding '${user_name}' to group '${group_name}'..."
    /usr/sbin/dseditgroup -o edit -a "${user_name}" -t user "${group_name}" >/dev/null
}


####
##  Print the available disk space for a given mount point or device path.
##  By default, the returned value is expressed in megabytes.
##
##  ARGUMENTS
##  ---------
##  --bytes:  Optional.  Express the returned available space in bytes instead
##      of megabytes.
##
##  $1: <volume_path>  The mount point or device path.  If no argument is
##      provided, the root path '/' will be used.
##
function free_in_volume ()  # [--bytes] <volume_path>
{
    typeset -i use_bytes=0
    [[ "${1}" == "--bytes" ]] && { use_bytes=1 ; shift ; }

    typeset volume_path="${1}"
    [[ -z "${volume_path}" ]] && { volume_path='/' } ||  # Use default if unset.  Otherwise...
    {
        [[ -d "${volume_path}" ]] ||  # Verify provided path is a directory.
        {
             echo_debug "Specified volume path '${volume_path}' is not a directory."
             return 1
        }
    }

    typeset volume_info && volume_info="$( /usr/sbin/diskutil info -plist "${volume_path}" )" ||
    {
        echo_debug "Unable to get disk info for '${volume_path}'."
        return $?
    }

    typeset free_bytes && free_bytes="$( echo "${volume_info}" | /usr/bin/plutil -extract 'APFSContainerFree' raw - )" ||
    {
        echo_debug "Unable to parse free disk space for '${volume_path}'."
        return $?
    }

    (( use_bytes )) &&
    {
        echo "${free_bytes}"
        return 0
    }

    # Limit MB format output to three decimal places.
    typeset -F 3 free_mbytes && free_mbytes=$(( free_bytes / (1024.0 ** 2) ))

    echo "${free_mbytes}"
}


####
##  Remove a file or directory, with a test for existence and debug log message.
##
##  ARGUMENTS
##  ---------
##  $1: <path_to_remove>  The path to the file or directory to be removed.
##
function remove_existing ()  # <path_to_remove>
{
    [[ -f "${1}" ]] && { echo_debug "Removing file '${1}'..."      ; /bin/rm  -f "${1}" ; return $? ; }
    [[ -d "${1}" ]] && { echo_debug "Removing directory '${1}'..." ; /bin/rm -rf "${1}" ; return $? ; }

    echo_debug "No file or directory exists at '${1}'... skipped."
    return 0
}


####
##  Print either the most recently logged-in user, or the user who logs in most
##  commonly, with options to filter out undesired users.
##
##  ARGUMENTS
##  ---------
##  <recent | common>  Operating Mode
##      'recent' : Print the name of the most recently logged-in user, filtered
##          by the options below.
##      'commmon' : Print the name of the user who logs in most commonly,
##          filtered by the options below.
##
##  FILTERING OPTIONS (Optional):
##      [-o | --online-only]  Consider only users who are currently logged in.
##      [-n | --include-non-sid]  Include users whose names do not appear to be
##          a standard identifier (a letter followed by siz digits).
##      [-t | --include-tty]  Include logins that are not bound to a console
##          session; i.e., non-GUI logins such as terminal or SSH sessions.
##
function user_most ()  # (recent | common) [-o | --online_only] [-n | --include-non-sid] [-t | --include-tty]
{
    # Parse the options given to the function.
    zmodload zsh/zutil || return 10
    zparseopts -D -E -F -- \
        {h,-help}=help \
        {o,-online-only}=online_only \
        {n,-include-non-sid}=include_non_sid \
        {t,-include-tty}=include_tty \
    || return 1

    # Configure the list of valid operating modes for this function.
    typeset -A modes=(
        mode_recent 'recent'
        mode_common 'common'
    )

    # Read the selected operating mode.  If the mode is not set or is not valid,
    # set the 'help' flag so that the usage text will be displayed.
    typeset mode="${1}"
    (( ${${(@v)modes}[(Ie)$mode]} )) || { help=( '--help' ) }

    # If the 'help' flag is set, display this function's usage text.
    if (( $#help )); then
        print -rC1 -- \
            "$0 [-h | --help]" \
            "$0 (${(j' | ')modes}) [-n | --include-non-sid] [-t | --include-tty] [-o | --online-only]"
        return 0
    fi

    # Configure 'awk' filter patterns to be ANDed together later.
    typeset -A filters=(
        is_not_blank  '(! /^$/)'
        is_not_status '(! /wtmp begins/)'
        is_sid        '($1 ~ /[[:alpha:]][[:digit:]]{6}/)'
        is_console    '($2 == "console")'
        is_online     '/still logged in/'
    )

    # Configure 'awk' actions which will be combined later.
    typeset -A actions=(
        print_first_field  'print $1'
        print_second_field 'print $2'
        stop_reading       'exit 0'
    )

    # Create arrays to hold the patterns and actions for this function run.
    # Populate with filters and required regardless of mode.
    typeset -a awk_filters=( "${filters[is_not_blank]}" "${filters[is_not_status]}" )
    typeset -a awk_actions=( "${actions[print_first_field]}" )

    # If we're in 'recent' mode, we'll stop reading after the filtering action.
    [[ "${mode}" == "${modes[mode_recent]}" ]] && { awk_actions+=( "${actions[stop_reading]}" ) }

    # Add filters based on flags passed to command.
    (( $#include_non_sid )) || { awk_filters+=( "${filters[is_sid]}" ) }
    (( $#include_tty ))     || { awk_filters+=( "${filters[is_console]}" ) }
    (( $#online_only ))     && { awk_filters+=( "${filters[is_online]}" ) }

    # Construct the 'awk' script, using the (j) zsh parameter expansion flag to
    # join the patterns and actions determined above.
    awk_script="${(j' && ')awk_filters} { ${(j'; ')awk_actions} }"

    # Run the 'awk' command, using the constructed script.
    awk_output=$( /usr/bin/last | awk "${awk_script}" )

    # If we're in 'recent' mode, we're done here... echo the output and exit.
    [[ "${mode}" == "${modes[mode_recent]}" ]] &&
    {
        echo "${awk_output}"
        return 0
    }

    # Otherwise, since we're in 'common' mode, pipe the output through a few
    # commands to determine the most frequent user.
    echo "${awk_output}" \
        | sort \
        | uniq -c \
        | sort -rn \
        | awk "{ ${actions[print_second_field]}; ${actions[stop_reading]} }"
}


####
##  Print a "unique" path for a given file path; useful when you wish to avoid
##  overwriting an existing file.
##
##  ARGUMENTS
##  ---------
##  $1: <path>  Path to test for uniqueness
##
##  BEHAVIOR
##  --------
##  Determines whether or not a file or directory exists at the given path.
##      * If no file/folder exists, function outputs the path unmodified.
##      * If file/folder exists, function attempts to generate a unique path by
##        appending the smallest-possible integer to the end which would result
##        in a unique file path.
##
function unique_path ()  # <path>
{
    typeset working_path="${1:a}" ; [[ -n "${working_path}" ]] || { echo_log 'Missing input path argument.' ERROR ; return 10 ; }
    typeset base_and_stem="${working_path:r}"
    typeset extension_with_dot="${${working_path:e}:+.${working_path:e}}"
    typeset -i index=0

    # Handle case of dotfile with no extension.  The fact that :r/:e don't
    # handle this properly should probably be considered to be a ZSH bug.
    # TODO: Report it: https://zsh.sourceforge.io/FAQ/zshfaq06.html
    [[ "${working_path:t}" == ".${working_path:e}" ]] &&
    {
        base_and_stem="${working_path}"
        unset extension_with_dot
    }

    while [[ -e $working_path ]] { working_path="${base_and_stem}-$((++index))${extension_with_dot}" ; }

    echo "${working_path}"
}


####
##  Replace the contents of target_file with those of source_file, preserving
##  the metadata and modification date of the target_file.
##
function mv_replace ()  # <source_file> <target_file>
{
    typeset source_file=${~"${1}"} ; [[ -n "${source_file}" && -f "${source_file}" ]] || { echo_log 'Argument for source file is missing or empty, or file does not exist.' ; return 10 ; }
    typeset target_file=${~"${2}"} ; [[ -n "${target_file}" && -f "${target_file}" ]] || { echo_log 'Argument for target file is missing or empty, or file does not exist.' ; return 11 ; }

    typeset target_date_modified && target_date_modified="$(stat -f "%Sm" -t "%C%y%m%d%H%M.%S" "${target_file}")" ||

    mv    -f       "${source_file}"          "${target_file}" || { echo_log 'Could not replace target file contents with source.' ERROR ; return $? ; }
    touch -c -m -t "${target_date_modified}" "${target_file}" || { echo_log 'Could not reset target file modification date to pre-operation date.' WARNING ; }

    return 0
}


####
##  Add an extension to files whose extension is incorrect, using the 'file'
##  command to assess the file's type and valid extensions.
##
##  ARGUMENTS
##  ---------
##  --validate-only : Dry run.  Print matching files without modification.
##
##  $1: <description_pattern>  Pattern which will be tested against the output
##      of the 'file --brief' command for each input file.  If the output of
##      the 'file' command does not match this pattern, it will be skipped.
##
##  #2: <replacement_extension>  The desired extension to append to files which
##      which do not have a proper extension.  This value will be checked
##      against the list of valid extensions returned by 'file --extension'.
##
##  $3-$n: <input_file ...>  The path to the file(s) to be evaluated.  Multiple
##      file paths and glob patterns can be provided.
##
##  EXAMPLE
##  -------
##  For every file (not folder) in the current path: if it contains JPEG data
##  and does not have a proper extension, add the extension 'jpg' to the file.
##
##      % fix_extension 'JPEG*' 'jpg' ^*.*(.)
##
function fix_extension ()  # [--validate-only] <description_pattern> <replacement_extension> <input_file ...>
{
    typeset -i validate_only=0

    [[ "${1}" = '--validate-only' ]] &&
    {
        echo_log "Validating only... no modifications will be made." INFO
        validate_only=1
        shift
    }

    [[ -n "${1}" ]] || { echo_log "Argument for 'file --brief' match pattern is missing or empty" ERROR ; return 10 ; }
    typeset file_command_pattern="${1}"

    shift ; [[ -n "${1}" ]] || { echo_log "Argument for replacement extension is missing or empty" ERROR ; return 30 ; }
    typeset replacement_extension="${1}"

    shift ; (( ${#@} )) || { echo_log "Input file(s) missing or empty" ERROR ; return 40 ; }
    typeset -a input_files=( ${@} )

    for input_file ( ${input_files} )
    {
        input_file=${~"${input_file}"}

        # If the output of `file` doesn't match what we're looking for, skip to the next file.
        [[ "$(file --brief -- ${input_file})" != ${~file_command_pattern} ]] && continue

        # Use the `file` command to determine the valid extensions for the file.
        typeset -a valid_extensions=( ${(s:/:)$(file --brief --extension ${input_file})} )

        # If the file's extension matches one of the specified extensions, skip to the next file.
        { [[ -n "${input_file:e}" ]] && (( $valid_extensions[(I)(#i)${input_file:e}] )) } && continue

        echo_log "Input file '${input_file}' extension should be one of: '${(j', ')valid_extensions}'." INFO

        (( $valid_extensions[(I)(#i)${replacement_extension}] )) ||
        {
            echo_log "Specified replacement extension '${}' is not valid for this file type." WARNING
            continue
        }

        (( validate_only )) && continue

        echo_log "Changing extension to '${replacement_extension}'." INFO 4 ' ' '-> '
        mv -- ${input_file} "${input_file:r}.${replacement_extension}"
    }
}


####
##  Remove macOS-specific Finder metadata files, stored as files prefixed with '._'
##
function remove_finder_metadata_files ()  # [--recursive] [--dry-run]
{
    typeset working_path='.'
    typeset -a remove_cmd=(rm -v -f)
    typeset -a file_brief_cmd=(file --brief)
    typeset file_brief_description="AppleDouble encoded Macintosh file"

    [[ "${1}" = '--recursive' ]] && { working_path='**' ; shift ; }
    [[ "${1}" = '--dry-run'    ]] && { remove_cmd='echo' ; }

    for macos_file ( ${~"${working_path}"}/._*(.N) )
    {
        [[ "$( "${file_brief_cmd[@]}" "${macos_file}" )" == "${file_brief_description}" ]] ||
        {
            echo "Not removing '${macos_file}' because '${file_brief_cmd}' does not describe it as '${file_brief_description}'."
            continue
        }

        "${remove_cmd[@]}" "${macos_file}"
    }
}


####
##  Print a recursive tree of files and folders from the given path.
##
function file_tree ()  # <start_path>
{
    typeset start_path=${~"${1}"}
    [[ -n "${start_path}" && -e "${start_path}" ]] || { echo_log 'Argument for starting path is missing or empty, or nothing exists at the specified path.' ERROR ; return 10 ; }

    find "${start_path}" | sed -e 's/[^-][^\/]*\// |/g' -e 's/|\([^ ]\)/|-\1/'
}


####
##  Prompt the user for a password using a secure (non-echoed) input, and echo
##  the entered text back to stdout.
##
##  This should be used in a context which will capture the output so that
##  sensitive information is not displayed on screen.
##
##  EXAMPLES
##  -------
##  Add a password item to the Keychain:
##      % security add-internet-password -A -a 'username' \
##        -s 'secure.website.domain.net' -r 'htps' \
##        -w "$(ask_for_password)" 'login'
##
##  Provide a password to the `curl` command:
##      % curl --user v076726:$(ask_for_password) ...
##
function ask_for_password ()
{
    typeset password_input
    read -s 'password_input?Password:'
    echo $password_input
}


####
##  Create a new directory for temporary files.  The location will be:
##  * a uniquely named directory
##      * inside a directory named after the script
##          * inside a directory named with `$JPMC_ORGANIZATION`
##              * located either in `$TMPDIR` (if it is set) or `/tmp/`.
##
##  For example, if `$TMPDIR` is not set, and this function is called from a
##  script named `do_something_awesome.zsh`, the new directory's path could be:
##  > `/tmp/net.jpmchase.gti.mac-engineering/do_something_awesome/0C4D2B82-C99D-4E1E-B71D-AD0577A8F507/`
##
function new_tmp_dir ()  # <purpose>
{
    typeset base_tmp_dir="${TMPDIR:-/tmp/}"
    typeset purpose="${1:-${ZSH_ARGZERO:t:r}}" # Use the script name if not set.

    [[ -n "${purpose}" ]] || { echo_log 'Purpose for the temporary directory may not be empty.' ERROR ; return 1 ; }

    typeset unique_id="$( /usr/bin/uuidgen )"
    typeset new_tmp_dir_path="${base_tmp_dir}${JPMC_ORGANIZATION}/${purpose}.${unique_id}"

    echo_debug "Creating empty temporary directory for script-related task at '${new_tmp_dir_path}'..."

    /bin/mkdir -p  "${new_tmp_dir_path}" &&
        /bin/chmod 700 "${new_tmp_dir_path}" ||
            { echo_log 'Unable to create or change mode on new temporary directory.' ERROR ; return $? ; }

    echo "${new_tmp_dir_path}"
}


####
##  Read the contents for the given AuthorizationDB right, formatted as an
##  XML property list.
##
function authdb_read ()  # <right_name>
{
    typeset right_name="${1}"
    echo_debug "Reading AuthorizationDB right '${right_name}'..."

    eval "$( ( /usr/bin/security authorizationdb read "${right_name}" ) \
            2> >(read_status=$(cat); typeset -p read_status) \
            > >(right_contents=$(cat); typeset -p right_contents); result_code=$?; typeset -p result_code )"

    (( result_code > 0 )) && { echo_log "Unable to read right '${right_name}'.  Error: '${read_status}'." ERROR ; return result_code ; }

    echo_debug "Contents of right '${right_name}' are as follows:\n${right_contents}"
    echo_debug "Read Status: '${read_status}'"
    echo "${right_contents}"
}


####
##  Update the contents of the given AuthorizationDB right.
##
##  The updated content can be specified as either a single rule (provided via
##  the second argument), or as an XML property list (provided via stdin).
##
function authdb_write ()  # <right_name> [rule_id | plist-content-via-stdin]
{
    typeset right_name="${1}"
    typeset rule_id="${2}"

    ###############################################################
    ## PATH 1 - UPDATE RIGHT TO DELEGATE TO rule_id SPECIFIED IN $2
    [[ -n "${rule_id}" ]] &&
    {
        echo_debug "Updating AuthorizationDB right to invoke rule '${rule_id}'..."
        /usr/bin/security authorizationdb write "${right_name}" "${rule_id}" ||
        {
            echo_log "Unable to update right '${right_name}'; the AuthDB 'write' operation failed." ERROR
            return 1
        }

        return 0
    }

    ###############################################
    ## PATH 2 - UPDATE RIGHT WITH CONTENTS OF STDIN
    echo_debug "Updating AuthorizationDB right '${right_name}' with Plist contents from stdin..."

    typeset right_contents && right_contents="$( [[ -t 0 ]] || cat - )"  ||
    {
        echo_log "Unable to update right '${right_name}'; no Plist content was provided via stdin." ERROR
        return 1
    }

    echo_debug "Updated contents of right '${right_name}' will be as follows:\n\n${right_contents}\n"

    echo "${right_contents}" | /usr/bin/security authorizationdb write "${right_name}" ||
    {
        echo_log "Unable to update right '${right_name}'; the AuthDB 'write' operation failed." ERROR
        return $?
    }
}


####
##  Remove an AuthorizationDB right.
##
function authdb_remove ()  # [--bypass-system-right-restriction] <right_name>
{
    typeset system_removal_flag='--bypass-system-right-restriction'
    typeset -i system_removal_enabled=0
    [[ "${1}" == "${system_removal_flag}" ]] && { system_removal_enabled=1 ; shift ; }

    typeset right_name="${1}"

    #################################################################
    ## HAPPY PATH: REMOVE NON-"system.*" RIGHT USING 'security' TOOL.

    [[ "${right_name}" != 'system.'* ]] &&
    {
        echo_debug "Removing right '${right_name}' from the AuthorizationDB..."

        /usr/bin/security authorizationdb remove "${right_name}" ||
        {
            echo_log "Unable to remove right '${right_name}' from the AuthDB." ERROR
            return $?
        }

        return 0
    }

    ##########################################################################
    ## TREACHEROUS PATH: REMOVE "system.*" RIGHT BY EDITING 'auth.db' DIRECTLY

    (( system_removal_enabled )) ||
    {
        echo_log "Rights which begin with 'system.' may not be removed without enabling system right removal." ERROR
        echo_log "You can forcibly remove the right named '${right_name}' by adding the '${system_removal_flag}' flag to this command." ERROR
        echo_log "PLEASE NOTE: Using this flag will sidestep Apple's logic, and edit the AuthorizationDB directly using SQLite commands." ERROR
        echo_log "This is highly undesirable, and should be avoided in standard practice." ERROR
        return 1
    }

    typeset authdb_file='/private/var/db/auth.db'
    typeset -a sqlite_cmd=('/usr/bin/sqlite3' '-bail' "${authdb_file}")
    typeset -i right_id

    echo_log "Bypassing Apple's logic to remove right '${right_name}' from the AuthorizationDB using SQLite commands."
    echo_log "This is highly undesirable, and should be avoided in standard practice." WARNING

    # VERIFY THAT A RULE EXISTS IN THE AUTH DB WITH THE SPECIFIED NAME.
    # RESTRICT QUERY TO "RIGHT" RULES ONLY (type = 1).  GRAB VALUE.
    right_id=$( "${sqlite_cmd[@]}" "SELECT id FROM rules WHERE name = '${right_name}' AND type = 1;" )  && (( right_id > 0 )) ||
    {
        echo_log "Unable to find right with name '${right_name}' in the Authorization DB." ERROR
        return 1
    }

    echo_debug "Right named '${right_name}' has ID '${right_id}' in the Authorization DB."

    typeset -a modification_query=(
        'PRAGMA    foreign_keys = ON;'
        'PRAGMA    temp_store   = MEMORY;'
        'PRAGMA    auto_vacuum  = FULL;'
        'PRAGMA    journal_mode = WAL;'
        '.filectrl persist_wal    ON'
        "DELETE FROM rules WHERE id = ${right_id};"
    )

    echo_debug "Executing database query:\n    ${(j'\n    ')modification_query}\n"
    echo "${(j'\n')modification_query}" | "${sqlite_cmd[@]}" ||
    {
        echo_log "SQLite query failed with status '$?'.  Right '${right_name}' will not be removed." ERROR
        return $?
    }

    return 0
}


####
##  Reset the configuration of the the given AuthorizationDB right to its
##  "factory-default" state, as provided by the SIP-protected reference at
##  `/System/Library/Security/authorization.plist`.
##
function authdb_factory_reset ()  # <right_name>
{
    typeset right_name="${1}"
    typeset factory_config_file='/System/Library/Security/authorization.plist'

    echo_debug "Resetting AuthorizationDB right '${right_name}' to its factory-default configuration from '${factory_config_file}'..."

    typeset factory_contents && factory_contents=$( /usr/libexec/PlistBuddy -x -c "Print :rights:${right_name}" "${factory_config_file}" )  ||
    {
        echo_log "Unable to fetch factory state for right '${right_name}'." ERROR
        return $?
    }

    echo "${factory_contents}" | authdb_write "${right_name}"
}


####
##  Returns launchd domain target for the local user's GUI session.
##
function launchd_local_user_domain_target ()
{
    echo "gui/$(local_user_uid))"
}


####
##  Boot out a list of launchd service targets.
##  A service target is the domain target (e.g., 'system' or 'gui/<UID>')
##  and the service name ('com.foo.bar'), seperated by a slash.
##
function launchd_boot_out_service_targets ()  # <service-target [...]>
{
    typeset -a service_targets=( $@ )
    typeset launch_service
    typeset -i launchctl_status

    for service_target ( ${service_targets} )
    {
        echo_debug "Booting out launchd service target '${service_target}'..."
        /bin/launchctl bootout "${service_target}" ||
        {
            # If launchctl exits with status 3 (No such process; i.e., not
            # bootstrapped), continue normally.  Otherwise, return the status
            # from launchctl.
            launchctl_status=$?
            (( launchctl_status == 3 )) && { echo_log "Service target '${service_target}' is not bootstrapped.  Skipping...'" INFO ; continue ; }

            return ${launchctl_status}
        }
    }

    return 0
}


####
##  Boot out a list of system-level launchd service targets with the specified
##  service names.  The 'system' domain target will be prefixed for you.
##
function launchd_boot_out_system_services_named ()  # <service-name-in-system-domain [...]>
{
    launchd_boot_out_service_targets ${@/#/system/}
}


####
##  Boot out a list of launchd service targets associated with the current
##  user's GUI launchd session.  The 'gui/<UID>' domain target will be
##  prefixed for you.
##
function launchd_boot_out_user_services_named ()  # <service-name-in-user-domain [...]>
{
    launchd_boot_out_service_targets ${@/#/$(launchd_local_user_domain_target)/}
}


####
##  Poll the pasteboard's contents, and run a command when it is modified.
##
##  TEMPLATE PLACEHOLDER
##  If command or arguments contain the substring '<PASTE>', that subtring will
##  be replaced by the pasteboard's contents.
##
# function when_pasteboard_changes ()  # [--one-run-only] [--interval <seconds>] command_template [arg_template ...]
# {
#     zmodload zsh/zutil || return 1

#     ## Create usage output.
#     typeset usage=(
#         "$0 [--help]"
#         "$0 [--one-run-only] [--interval <seconds>] command_template [arg_template ...]"
#     )

#     ## Define parameter defaults.
#     typeset -a flag_help=( $( (( $# > 0 )) || echo "NO_ARGS" ) )
#     typeset -a flag_once=( )
#     typeset    default_interval='5'
#     typeset -a arg_interval=( ${default_interval} )

#     ## Parse function arguments.
#     zparseopts -D -F -K -- \
#         -help=flag_help \
#         -one-run-only=flag_once \
#         -interval:=arg_interval \
#     || return 1

#     ## Display usage if help flag is set, or if no command was provided.
#     (( ${#flag_help} || (! ${#@}) )) && { print -l $usage && return 0 ; }

#     typeset -F 4 interval=$(( ${arg_interval[-1]} ))
#     (( interval )) || interval=${default_interval}

#     while ( true ) { echo "$@" ; sleep "${interval}" ; }
# }

# function when_pasteboard_changes() # [--every <seconds>] command_template [arg_template ...]
# {
#     ## Create usage output.
#     typeset usage=(
#         "$0 [--help]"
#         "$0 [--every <seconds>] command_template [arg_template ...]"
#     )

#     zmodload zsh/zutil || return 1
#     typeset -a flag_help=()
#     typeset -a arg_every=()
#     zparseopts -D -F -K -- \
#         -help=flag_help \
#         -every:=arg_every \
#     || return 1

#     ## Display usage if help flag is set, or if no command was provided.
#     (( ${#flag_help} || (! ${#@}) )) && { print -l $usage && return 0 ; }

#     typeset -U array_every=( ${(ps::)arg_every[-1]} )
#     (( ${#array_every} == 1 )) && [[ "" ]]

#     # Cast the specified 'every' interval to a float.
#     typeset -F 4 interval=$(( ${arg_every[-1]} ))

#     # If the interval is less than zero, prepare to execute only once.
#     typeset -a return_if_interval_lt_zero=()
#     (( interval < 0 )) && { return_if_interval_lt_zero=( 'return' '0' ) }

#     while ( true )
#     {
#         #if the pasteboard value has changed
#         {
#             echo "$@"
#             ${return_if_interval_lt_zero}
#             sleep "${interval}"
#         }
#     }
# }


####
# #  Download a large file, broken into chunks of a specified size
# #  (in megabytes, default is 20).
# #
# function download_chunked ()  # <remote_url> <output_file_path> <chunk_size=20>
# {
#     typeset dl_command remote_url output_file_path chunk_input
#     typeset -i chunk_size
#
#     dl_command="curl"
#
#     remote_url="${1}" ; [[ -n "${remote_url}" ]] || fail 'Argument for remote URL is missing or empty.' 10
#     output_file_path="${2}" ; [[ -n "${output_file_path}" ]] || fail 'Argument for output path is missing or empty.' 20
#     # Check output path's last directory exists, or fail
#     # Check output path's last directory is writable, or fail
#     chunk_input="${3}" ; [[ "${chunk_size}" == <-> ]] || { chunk_input='' ; echo "Specified chunk size is not valid.' INFO }
#     (( chunk_size = $chunk_input )) ; [[ "${chunk_size}" == <-> && -n "${chunk_size}" ]] || echo 'Using default chunk size of 20 MB.' INFO
#     # Check that chunk size is a non-zero integer, or log that the default will be used
#
#
# }

